\section{File formats}
\label{section:formats}


\subsection{HMM save files}
\label{section:savefiles}

The file \prog{tutorial/rrm.hmm} gives an example of a HMMER3 ASCII
save file. An abridged version is shown here, where (\ldots) mark
deletions made for clarity and space:

\begin{tinysreoutput}
HMMER3/a [3.0.dev | March 2008]
NAME  RRM_1
ACC   PF00076.13
DESC  RNA recognition motif. (a.k.a. RRM, RBD, or RNP domain)
LENG  72
ALPH  amino
RF    no
CS    yes
MAP   yes
DATE  Fri Oct 10 10:29:38 2008
COM   [1] ./hmmbuild RRM_1 RRM_1.sto
NSEQ  79
EFFN  7.722980
CKSUM 512533816
STATS LOCAL     VLAMBDA 0.721565
STATS LOCAL         VMU -8.724843
STATS LOCAL        FTAU -4.034479
HMM          A        C        D        E        F        G        H        I     (...)    Y
            m->m     m->i     m->d     i->m     i->i     d->m     d->d
  COMPO   2.59889  4.44747  2.92534  2.57970  2.91651  2.81030  3.90624  2.78237  (...) 3.49702
          2.68618  4.42225  2.77519  2.73123  3.46354  2.40513  3.72494  3.29354  (...) 3.61503
          0.00484  5.72961  6.45195  0.61958  0.77255  0.00000        *
      1   3.33305  4.36957  6.20460  5.67416  4.57399  5.57414  6.09195  1.31189  (...) 5.28530      1 - E
          2.68618  4.42225  2.77519  2.73123  3.46354  2.40513  3.72494  3.29354  (...) 3.61503
          0.00484  5.72961  6.45195  0.61958  0.77255  0.48576  0.95510
      2   3.33570  4.71399  5.27635  4.66262  1.20335  3.96868  4.83458  2.71778  (...) 1.66170      2 - E
          2.68618  4.42225  2.77519  2.73123  3.46354  2.40513  3.72494  3.29354  (...) 3.61503
          0.00484  5.72961  6.45195  0.61958  0.77255  0.48576  0.95510
(...)
     71   3.08639  5.73256  2.87655  2.29760  4.27257  3.66073  3.11090  3.98349  (...) 3.32445     79 - E
          2.68618  4.42225  2.77519  2.73123  3.46354  2.40513  3.72494  3.29354  (...) 3.61503
          0.00484  5.72961  6.45195  0.61958  0.77255  0.48576  0.95510
     72   2.98106  3.47896  4.24834  4.59436  3.48125  4.49311  4.82169  1.78353  (...) 4.16621     80 - E
          2.68618  4.42225  2.77519  2.73123  3.46354  2.40513  3.72494  3.29354  (...) 3.61503
          0.00326  5.72803        *  0.61958  0.77255  0.00000        *
//
\end{tinysreoutput}


An HMM file consists of one or more HMMs.  Each HMM starts with the
identifier \prog{HMMER3/a} and ends with \prog{//} on a line by
itself.  The identifier allows backward compatibility as the HMMER
software evolves: it tells the parser this file is from HMMER3's save
file format version a.  The closing \prog{//} allows multiple HMMs to
be concatenated.

The format is divided into two regions. The first region contains
textual information and miscalleneous parameters in a roughly
tag-value scheme.  This section ends with a line beginning with the
keyword \prog{HMM}. The second region is a tabular, whitespace-limited
format for the main model parameters.

All probability parameters are all stored as negative natural log
probabilities with five digits of precision to the right of the
decimal point, rounded. For example, a probability of $0.25$ is stored
as $-\log 0.25 = 1.38629$. The special case of a zero probability is
stored as '*'.

Spacing is arranged for human readability, but the parser only cares
that fields are separated by at least one space character.

A more detailed description of the format follows.

\subsubsection{header section}

The header section is parsed line by line in a tag/value format. Each
line type is either \textbf{mandatory} or \textbf{optional} as
indicated. 

\begin{wideitem}

\item [\emprog{HMMER3/a}] Unique identifier for the save file format
version; the \prog{/a} means that this is HMMER3 HMM file format
version a. If HMMER3 ever changes its save file format, the revision
code will change from a to b. This way, parsers may easily remain
backwards compatible. The remainder of the line after the
\prog{HMMER3/a} tag is free text that is ignored by the parser. HMMER
currently writes its version number and release date in brackets here,
e.g. \prog{[3.0.dev | March 2008]} in this
example. \textbf{Mandatory.}

\item [\emprog{NAME <s>}] Model name; \prog{<s>} is a single word
containing no spaces or tabs. The name is normally picked up from the
\verb+#=GF ID+ line from a Stockholm alignment file.  If this is not
present, the name is created from the name of the alignment file by
removing any file type suffix. For example, an otherwise nameless HMM
built from the alignment file \prog{rrm.slx} would be named
\prog{rrm}.  \textbf{Mandatory.}

\item [\emprog{ACC <s>}] Accession number; \prog{<s>} is a one-word
accession number. This is picked up from the \verb+#=GF AC+ line in a
Stockholm format alignment. \textbf{Optional.}

\item [\emprog{DESC <s>}] Description line; \prog{<s>} is a one-line
free text description. This is picked up from the \verb+#=GF DE+ line
in a Stockholm alignment file. \textbf{Optional.}

\item [\emprog{LENG <d>}] Model length; \prog{<d>}, a positive nonzero
integer, is the number of match states in the model.
\textbf{Mandatory.}

\item [\emprog{ALPH <s>}] Symbol alphabet type. For biosequence
analysis models, \prog{<s>} is \prog{amino}, \prog{DNA}, or \prog{RNA}
(case insensitive). There are also other accepted alphabets for
purposes beyond biosequence analysis, including \prog{coins},
\prog{dice}, and \prog{custom}. This determines the symbol alphabet
and the size of the symbol emission probability distributions.  If
\prog{amino}, the alphabet size $K$ is set to 20 and the symbol
alphabet to ``ACDEFGHIKLMNPQRSTVWY'' (alphabetic order); if
\prog{DNA}, the alphabet size $K$ is set to 4 and the symbol alphabet
to ``ACGT''; if \prog{RNA}, the alphabet size $K$ is set to 4 and the
symbol alphabet to ``ACGU''. \textbf{Mandatory.}

\item [\emprog{RF <s>}] Reference annotation flag; \prog{<s>} is
either \prog{no} or \prog{yes} (case insensitive). If \prog{yes}, the
reference annotation character field for each match state in the main
model (see below) is valid; if \prog{no}, these characters are
ignored.  Reference column annotation is picked up from a Stockholm
alignment file's \verb+#=GC RF+ line. It is propagated to alignment
outputs, and also may optionally be used to define consensus match
columns in profile HMM construction. \textbf{Optional}; assumed to be
no if not present.

\item [\emprog{CS <s>}] Consensus structure annotation flag;
\prog{<s>} is either \prog{no} or \prog{yes} (case insensitive). If
\prog{yes}, the consensus structure character field for each match
state in the main model (see below) is valid; if \prog{no} these
characters are ignored. Consensus structure annotation is picked up
from a Stockholm file's \verb+#=GC SS_cons+ line, and propagated to
alignment displays.  \textbf{Optional}; assumed to be no if not
present.

\item [\emprog{MAP <s>}] Map annotation flag; \prog{<s>} is either
\prog{no} or \prog{yes} (case insensitive).  If set to \prog{yes}, the
map annotation field in the main model (see below) is valid; if
\prog{no}, that field will be ignored.  The HMM/alignment map
annotates each match state with the index of the alignment column from
which it came. It can be used for quickly mapping any subsequent
HMM alignment back to the original multiple alignment, via the model.
\textbf{Optional}; assumed to be no if not present.

\item [\emprog{DATE <s>}] Date the model was constructed; \prog{<s>}
is a free text date string.  This field is only used for logging
purposes.\footnote{HMMER does not use dates for any purpose other than
human-readable annotation, so it is no more prone than you are to Y2K,
Y2038, or any other date-related eschatology.} \textbf{Optional.}

\item [\emprog{COM [<n>] <s>}] Command line log; \prog{<n>} counts
command line numbers, and \prog{<s>} is a one-line command. There may
be more than one \prog{COM} line per save file, each numbered starting
from $n=1$. These lines record every HMMER command that modified the
save file. This helps us reproducibly and automatically log how Pfam
models have been constructed, for example. \textbf{Optional.}

\item [\emprog{NSEQ  <d>}] Sequence number; \prog{<d>} is a nonzero
positive integer, the number of sequences that the HMM was trained on.
This field is only used for logging purposes.
\textbf{Optional.}

\item [\emprog{EFFN <f>}] Effective sequence number; \prog{<f>} is a
nonzero positive real, the effective total number of sequences
determined by \prog{hmmbuild} during sequence weighting, for combining
observed counts with Dirichlet prior information in parameterizing the
model. This field is only used for logging purposes.
\textbf{Optional.}

\item [\emprog{CKSUM <d>}] Training alignment checksum; \prog{<d>} is
a nonnegative 32-bit integer. This number is calculated from the
training sequence data, and used in conjunction with the alignment map
information to verify that a given alignment is indeed the alignment
that the map is for. \textbf{Optional.}

\item [\emprog{GA    <f> <f>}] Pfam gathering thresholds GA1 and GA2.
See Pfam documentation of GA lines. \textbf{Optional.}

\item [\emprog{TC <f> <f>}] Pfam trusted cutoffs TC1 and TC2.  See
Pfam documentation of TC lines. \textbf{Optional.}

\item [\emprog{NC <f> <f>}] Pfam noise cutoffs NC1 and NC2.  See Pfam
documentation of NC lines. \textbf{Optional.}

\item [\emprog{STATS <s1> <s2> <f>}] Statistical parameters needed for
E-value calculations. \prog{<s1>} is the model's alignment mode
configuration: currently only \prog{LOCAL} is recognized. \prog{<s2>}
is the name of the parameter: currently \prog{VLAMBDA}, \prog{VMU},
and \prog{FTAU} are recognized, representing the Viterbi score slope
parameter $\lambda$, Viterbi score location parameter $\mu$, and
Forward score location parameter $\tau$ \citep{Eddy08}. Each parameter
is a real number \prog{f}; $\lambda$ must be positive. Either all
three lines or none of them must be present: when all three are
present, the model is considered to be calibrated for E-value
statistics. \textbf{Optional.}

\item [\emprog{HMM }] Flags the start of the main model
section. Solely for human readability of the tabular model data, the
symbol alphabet is shown on the \prog{HMM} line, aligned to the fields
of the match and insert symbol emission distributions in the main
model below. The next line is also for human readability, providing
column headers for the state transition probability fields in the main
model section that follows. Though unparsed after the \prog{HMM} tag,
the presence of two header lines is \textbf{mandatory:} the parser
always skips the line after the \prog{HMM} tag line.

\item [\emprog{COMPO <f>*K}] The first line in the main model section
may be an optional line starting with \emprog{COMPO}: these are the
model's overall average match state emission probabilities, which are
used as a background residue composition in the ``filter null''
model. The $K$ fields on this line are log probabilities for each
residue in the appropriate biosequence alphabet's
order. \textbf{Optional.}

\end{wideitem}

\subsubsection{main model section}

All the remaining fields are \textbf{mandatory}.

The first two lines in the main model section are atypical. They
contain information for the core model's BEGIN node. This is stored as
model node 0, and match state 0 is treated as the BEGIN state.  The
begin state is mute, so there are no match emission probabilities. The
first line is the insert 0 emissions. The second line contains the
transitions from the begin state and insert state 0.  These seven
numbers are: $B \rightarrow M_1$, $B \rightarrow I_0$, $B \rightarrow
D_1$; $I_0 \rightarrow M_1$, $I_0 \rightarrow I_0$; and by convention,
nonexistent transitions from the nonexistent delete state 0 are set to
$\log 1 = 0$ and $\log 0 = -\infty = $ `*'.

The remainder of the model has three lines per node, for $M$ nodes
(where $M$ is the number of match states, as given by the \prog{LENG}
line). These three lines are ($K$ is the alphabet size in residues):

\begin{wideitem}

\item [\textbf{Match emission line}] The first field is the node
number ($1 \ldots M$).  The parser verifies this number as a
consistency check (it expects the nodes to come in order). The next
$K$ numbers for match emissions, one per symbol, in alphabetic order.

The next field is the \prog{MAP} annotation for this node.  If
\prog{MAP} was \prog{yes} in the header, then this is an integer,
representing the alignment column index for this match state
(1..alen); otherwise, this field is `-'.

The next field is the \prog{RF} annotation for this node.  If
\prog{RF} was \prog{yes} in the header, then this is a single
character, representing the reference annotation for this match state;
otherwise, this field is `-'.

The next field is the \prog{CS} annotation for this node.  If
\prog{CS} was \prog{yes}, then this is a single character,
representing the consensus structure at this match state; otherwise
this field is `-'.

\item [\textbf{Insert emission line}] The $K$ fields on this line are
the insert emission scores, one per symbol, in alphabetic order.

\item [\textbf{State transition line}] The seven fields on this line
are the transitions for node $k$, in the order shown by the transition
header line: $M_k \rightarrow M_{k+1}, I_{k}, D_{k+1}$; $ I_k
\rightarrow M_{k+1}, I_k$; $D_{k} \rightarrow M_{k+1}, D_{k+1}$.

For transitions from the final node $M$, match state $M+1$ is
interpreted as the END state $E$, and there is no delete state $M+1$;
therefore the final $M_k \rightarrow D_{k+1}$ and $D_k \rightarrow
D_{k+1}$ transitions are always * (zero probability), and the final
$D_k \rightarrow M_{k+1}$ transition is always 0.0 (probability 1.0).
\end{wideitem}

Finally, the last line of the format is the ``//'' record separator.


\subsection{HMMER null model files}

A ``null model'' is used to calculate HMMER log odds scores. The null
model states the expected background occurrence frequencies of the 20
amino acids or the 4 nucleotide bases. The null model also contains a
parameter called p1, which is the $G \rightarrow G$ transition
probability in the Plan7 null model (see the figure in the
Introduction).

For protein models, by default, the 20 residue frequencies are set to
the amino acid composition of SWISS-PROT 34, and p1 is set to 350/351
(which, because the Plan7 null model implies a geometric length
distribution, states that the mean length of a protein is about 350
residues). For DNA/RNA models, by default, the 4 residue frequencies
are set to 0.25 each, and p1 is set to 1000/1001.  [In the code, see
\prog{prior.c:P7DefaultNullModel()}, and the amino acid frequencies are
set in \prog{iupac.c:aafq}.]

Each HMM carries its own null model (see above, HMM file format).  The
null model is determined when the model is built using
\prog{hmmbuild}. The default null model can be overridden using
the \prog{--null <f>} option to \prog{hmmbuild}, where \prog{<f>} is
the name of a null model file.  

Two example null model files, \prog{amino.null} and
\prog{nucleic.null}, are provided in the \prog{tutorial} subdirectory
of the HMMER distribution. (They are copies of the internal default
HMMER null model settings.)  \prog{nucleic.null} looks like this:

\begin{sreoutput}
# nucleic.null
#
# Example of a null model file for DNA/RNA sequences.
# The values in this file are the HMMER 2 default
# settings.

Nucleic
0.25     # A
0.25     # C
0.25     # G
0.25     # T
0.999001 # p1
\end{sreoutput}

Anything on a line following a \prog{\#} is a comment, and is ignored
by the software. Blank lines are also ignored. Valid fields are
separated by blanks or new lines. Only the order that the fields occur
in the file is important, not how they're put on lines; for example,
20 required fields can all occur on one line separated by blanks, or
on 20 separate lines. 

There must be 6 or 22 non-comment fields in a null model file,
occurring in the following order:

\begin{wideitem}
\item [\textbf{Alphabet type}] The first (non-comment) word in the
file must be Nucleic or Amino, specifying what kind of sequence the
null model is for.

\item [\textbf{Emission probabilities}] 4 or 20 background
frequencies for the amino acids or nucleotides. These \textit{must}
come in alphabetical order (the A, C, G, T comments in the example
above are only for easier human viewing, and aren't parsed by the
software).

\item [\textbf{p1 probability}] The $G \rightarrow G$ transition
probability in the null model. Basically, if the expected mean length
of target sequences is $x$, p1 should be $\frac{x}{x+1}$.
\end{wideitem}

Null model files are parsed in \prog{prior.c:P7ReadNullModel()}.

\subsection{HMMER prior files}
\label{section:priorfiles}

Observed counts of emissions (residues) and transitions (insertions
and deletions) in a multiple alignment are combined with
\textit{Dirichlet priors} to convert them to probabilities
in an HMM. 

For protein models, by default, HMMER uses a nine-component mixture
Dirichlet prior for match emissions, and single component Dirichlet
priors for insert emissions and transitions. The nine-component match
emission mixture Dirichlet comes from the work of Kimmen Sj\"{o}lander
\cite{Sjolander96}.

For DNA/RNA models, by default, HMMER uses single component
Dirichlets.

Two example null model files, \prog{amino.pri} and \prog{nucleic.pri},
are provided in the \prog{tutorial} subdirectory of the HMMER
distribution. (They are copies of the internal default HMMER prior
settings.)

The way the format of these files is parsed is identical to null
models: everything after a \prog{\#} on a line is a comment, the order
of occurrence of the fields is important, and fields must be separated
by either blanks or newlines.

A prior file consists of the following fields:

\begin{wideitem}
\item [\textbf{Strategy}] Must be the keyword \prog{Dirichlet}. Currently 
this is the only available prior strategy in the public HMMER release.

\item [\textbf{Alphabet type}] Must be either \prog{Amino} or
\prog{Nucleic}.

\item [\textbf{Transition priors}] 1 + 8a fields, where a
is the number of transition mixture components. The first field is the
number of transition prior components, a (often just 1). Then, for each
component, eight fields follow: the prior probability of that mixture
component (1.0 if there is only one component), then the Dirichlet
alpha parameters for the seven transitions, in order of $M \rightarrow
M$, $M \rightarrow I$, $M \rightarrow D$, $I \rightarrow M$, $I
\rightarrow I$, $D \rightarrow M$, $D \rightarrow I$.

\item [\textbf{Match emission priors}] 1 + (5 or 21)b fields,
where b is the number of match emission mixture components.  The first
field is the number of match emission mixture components, b. Then, for
each component, 5 or 21 fields follows: the prior probability of that
mixture component (1.0 if there is only one component), then the
Dirichlet alpha parameters for the 4 or 20 residue types, in
alphabetical order.

\item [\textbf{Insert emission priors}] 1 + (5 or 21)c fields,
where c is the number of insert emission mixture components.  The
first field is the number of insert emission mixture components,
c. Then, for each component, 5 or 21 fields follows: the prior
probability of that mixture component (1.0 if there is only one
component), then the Dirichlet alpha parameters for the 4 or 20
residue types, in alphabetical order.
\end{wideitem}

In the code, prior files are parsed by \prog{prior.c:P7ReadPrior()}.

\subsection{Sequence files}

\subsubsection{supported file formats}
 
HMMER can automatically recognize and parse a number of common file
formats. The best supported of these formats are listed below. If you
know your sequence database is in one of these formats, you can use
the file. If you are formatting sequences yourself, see the section of
FASTA format below for unaligned sequences, and the section on
Stockholm format for alignments; these are the recommended native
formats for HMMER.

\begin{tabular}{ll}
\multicolumn{2}{l}{\textbf{Unaligned sequence formats}} \\
FASTA      & Pearson FASTA format; BLAST databases \\
SWISS-PROT & SWISS-PROT protein sequence database\\ 
PIR        & PIR protein sequence database \\
EMBL       & EMBL DNA sequence database \\
GenBank    & GenBank DNA database flat files\\
GCGdata    & Wisconsin GCG sequence database format \\
GCG        & Wisconsin GCG single sequence format \\
\end{tabular}

\begin{tabular}{ll}
\multicolumn{2}{l}{\textbf{Multiple sequence alignment formats}}\\
Stockholm & The preferred format for HMMER/Pfam (see below)\\
SELEX     & The old format for HMMER/Pfam\\
GCG MSF   &   GCG alignment format \\
CLUSTAL   &   CLUSTALW and CLUSTALV format \\
PHYLIP    &   Phylip phylogenetic software format \\
\end{tabular}

For programs that do sequential, database-style access (i.e.  where
you'd usually use an unaligned flat file), the alignment formats are
read as if they were multiple unaligned sequences.

There is no provision for enforcing that single unaligned sequence
formats (i.e. GCG unaligned sequence format) are single sequence
only. HMMER will happily try to read more than one sequence if your
file contains more than one. However, this may not give the results
you expected.

Staden ``experiment file'' format is parsed using the EMBL file
parser, but this functionality is relatively unsupported. There is one
wrinkle in this. Staden experiment files use '-' characters to
indicate 'N' -- i.e., that a base is present in a sequence read, but
its identity is unknown. Therefore, the software replaces any '-' in
an EMBL sequence with an 'N'. Sometimes people use the unaligned
formats to distribute aligned sequences by including gap
characters. If EMBL files are used i this way for aligned strings,
they must use a different character than '-' to indicate gaps.

\subsection{FASTA unaligned sequence format}

An example of a simple FASTA file: 

\begin{verbatim}
>seq1 This is the description of my first sequence.
AGTACGTAGTAGCTGCTGCTACGTGCGCTAGCTAGTACGTCA
CGACGTAGATGCTAGCTGACTCGATGC
>seq2 This is a description of my second sequence.
CGATCGATCGTACGTCGACTGATCGTAGCTACGTCGTACGTAG
CATCGTCAGTTACTGCATGCTCG
\end{verbatim}

FASTA is probably the simplest of formats for unaligned sequences.
FASTA files are easily created in a text editor.  Each sequence is
preceded by a line starting with \verb+>+. The first word on this line
is the name of the sequence. The rest of the line is a description of
the sequence (free format). The remaining lines contain the sequence
itself. You can put as many letters on a sequence line as you want.

Blank lines in a FASTA file are ignored, and so are spaces or other
gap symbols (dashes, underscores, periods) in a sequence. Any other
non-amino or non-nucleic acid symbols in the sequence should produce
an appropriately strident string of warnings on your terminal screen
when you try to use the file.


\subsection{Stockholm, the recommended multiple sequence alignment format}

While we recommend a community standard format (FASTA) for unaligned
sequence files, the recommended multiple alignment file format is not
a community standard.  The Pfam Consortium developed a format (based
on extended SELEX) called ``Stockholm format''.  The reasons for this
are two-fold. First, there really is no standard accepted format for
multiple sequence alignment files, so we don't feel guilty about
inventing a new one. Second, the formats of popular multiple alignment
software (e.g. CLUSTAL, GCG MSF, PHYLIP) do not support rich
documentation and markup of the alignment.  Stockholm format was
developed to support extensible markup of multiple sequence
alignments, and we use this capability extensively in both RNA work
(with structural markup) and the Pfam database (with extensive use of
both annotation and markup).

\subsubsection{a minimal Stockholm file}
\begin{sreoutput}
# STOCKHOLM 1.0

seq1  ACDEF...GHIKL
seq2  ACDEF...GHIKL
seq3  ...EFMNRGHIKL

seq1  MNPQTVWY
seq2  MNPQTVWY
seq3  MNPQT...
//
\end{sreoutput}

The simplest Stockholm file is pretty intuitive, easily generated in a
text editor. It is usually easy to convert alignment formats into a
``least common denominator'' Stockholm format. For instance, GCG's MSF
format and the output of the CLUSTAL multiple alignment programs are
similar interleaved formats.

The first line in the file must be \verb+# STOCKHOLM 1.x+, where
\verb+x+ is a minor version number for the format specification
(and which currently has no effect on my parsers). This line allows a
parser to instantly identify the file format.

In the alignment, each line contains a name, followed by the aligned
sequence. A dash or period denotes a gap. If the alignment is too long
to fit on one line, the alignment may be split into multiple blocks,
with blocks separated by blank lines. The number of sequences, their
order, and their names must be the same in every block. Within a given
block, each (sub)sequence (and any associated \verb+#=GR+ and
\verb+#=GC+ markup, see below) is of equal length, called the
\textit{block length}. Block lengths may differ from block to block;
the block length must be at least one residue, and there is no
maximum.  

Other blank lines are ignored. You can add comments to the file on
lines starting with a \verb+#+.

All other annotation is added using a tag/value comment style. The
tag/value format is inherently extensible, and readily made
backwards-compatible; unrecognized tags will simply be ignored. Extra
annotation includes consensus and individual RNA or protein secondary
structure, sequence weights, a reference coordinate system for the
columns, and database source information including name, accession
number, and coordinates (for subsequences extracted from a longer
source sequence) See below for details.

\subsubsection{syntax of Stockholm markup}

There are four types of Stockholm markup annotation, for per-file,
per-sequence, per-column, and per-residue annotation:

\begin{wideitem}
\item [\emprog{\#=GF <tag> <s>}]
        Per-file annotation. \prog{<s>} is a free format text line
        of annotation type \prog{<tag>}. For example, \prog{\#=GF DATE
        April 1, 2000}. Can occur anywhere in the file, but usually
        all the \prog{\#=GF} markups occur in a header.

\item [\emprog{\#=GS <seqname> <tag> <s>}]
        Per-sequence annotation. \prog{<s>} is a free format text line
        of annotation type \prog{tag} associated with the sequence
        named \prog{<seqname>}. For example, \prog{\#=GS seq1
        SPECIES\_SOURCE Caenorhabditis elegans}. Can occur anywhere
        in the file, but in single-block formats (e.g. the Pfam
        distribution) will typically follow on the line after the
        sequence itself, and in multi-block formats (e.g. HMMER
        output), will typically occur in the header preceding the
        alignment but following the \prog{\#=GF} annotation.

\item [\emprog{\#=GC <tag> <...s...>}]
        Per-column annotation. \prog{<...s...>} is an aligned text line
        of annotation type \prog{<tag>}.
        \verb+#=GC+ lines are
        associated with a sequence alignment block; \prog{<...s...>}
        is aligned to the residues in the alignment block, and has
        the same length as the rest of the block.
        Typically \verb+#=GC+ lines are placed at the end of each block.

\item [\emprog{\#=GR <seqname> <tag> <.....s.....>}]
        Per-residue annotation. \prog{<...s...>} is an aligned text line
        of annotation type \prog{<tag>}, associated with the sequence
        named \prog{<seqname>}. 
        \verb+#=GR+ lines are 
        associated with one sequence in a sequence alignment block; 
        \prog{<...s...>}
        is aligned to the residues in that sequence, and has
        the same length as the rest of the block.
        Typically
        \verb+#=GR+ lines are placed immediately following the
        aligned sequence they annotate.
\end{wideitem}

\subsubsection{semantics of Stockholm markup}

Any Stockholm parser will accept syntactically correct files, but is
not obligated to do anything with the markup lines. It is up to the
application whether it will attempt to interpret the meaning (the
semantics) of the markup in a useful way. At the two extremes are the
Belvu alignment viewer and the HMMER profile hidden Markov model
software package.

Belvu simply reads Stockholm markup and displays it, without trying to
interpret it at all. The tag types (\prog{\#=GF}, etc.) are sufficient
to tell Belvu how to display the markup: whether it is attached to the
whole file, sequences, columns, or residues.

HMMER uses Stockholm markup to pick up a variety of information from
the Pfam multiple alignment database. The Pfam consortium therefore
agrees on additional syntax for certain tag types, so HMMER can parse
some markups for useful information. This additional syntax is imposed
by Pfam, HMMER, and other software of mine, not by Stockholm format
per se. You can think of Stockholm as akin to XML, and what my
software reads as akin to an XML DTD, if you're into that sort of
structured data format lingo.

The Stockholm markup tags that are parsed semantically by my software
are as follows:

\subsubsection{recognized \#=GF annotations}
\begin{wideitem}
\item [\emprog{ID  <s>}] 
        Identifier. \emprog{<s>} is a name for the alignment;
        e.g. ``rrm''. One word. Unique in file.

\item [\emprog{AC  <s>}]
        Accession. \emprog{<s>} is a unique accession number for the
        alignment; e.g. 
        ``PF00001''. Used by the Pfam database, for instance. 
        Often a alphabetical prefix indicating the database
        (e.g. ``PF'') followed by a unique numerical accession.
        One word. Unique in file. 
        
\item [\emprog{DE  <s>}]
        Description. \emprog{<s>} is a free format line giving
        a description of the alignment; e.g.
        ``RNA recognition motif proteins''. One line. Unique in file.

\item [\emprog{AU  <s>}]
        Author. \emprog{<s>} is a free format line listing the 
        authors responsible for an alignment; e.g. 
        ``Bateman A''. One line. Unique in file.

\item [\emprog{GA  <f> <f>}]
        Gathering thresholds. Two real numbers giving HMMER bit score
        per-sequence and per-domain cutoffs used in gathering the
        members of Pfam full alignments. 
        
\item [\emprog{NC  <f> <f>}]
        Noise cutoffs. Two real numbers giving HMMER bit score
        per-sequence and per-domain cutoffs, set according to the
        highest scores seen for unrelated sequences when gathering
        members of Pfam full alignments.

\item [\emprog{TC  <f> <f>}]
        Trusted cutoffs. Two real numbers giving HMMER bit score
        per-sequence and per-domain cutoffs, set according to the
        lowest scores seen for true homologous sequences that
        were above the GA gathering thresholds, when gathering
        members of Pfam full alignments. 
\end{wideitem}

\subsubsection{recognized \#=GS annotations}

\begin{wideitem}
\item [\emprog{WT  <f>}]
        Weight. \emprog{<f>} is a positive real number giving the
        relative weight for a sequence, usually used to compensate
        for biased representation by downweighting similar sequences.   
        Usually the weights average 1.0 (e.g. the weights sum to
        the number of sequences in the alignment) but this is not
        required. Either every sequence must have a weight annotated, 
        or none of them can.  

\item [\emprog{AC  <s>}]
        Accession. \emprog{<s>} is a database accession number for 
        this sequence. (Compare the \prog{\#=GF AC} markup, which gives
        an accession for the whole alignment.) One word. 
        
\item [\emprog{DE  <s>}]
        Description. \emprog{<s>} is one line giving a description for
        this sequence. (Compare the \prog{\#=GF DE} markup, which gives
        a description for the whole alignment.)
\end{wideitem}


\subsubsection{recognized \#=GC annotations}

\begin{wideitem}
\item [\emprog{RF}]
        Reference line. Any character is accepted as a markup for a
        column. The intent is to allow labeling the columns with some
        sort of mark.
        
\item [\emprog{SS\_cons}]
        Secondary structure consensus. For protein alignments,
        DSSP codes or gaps are accepted as markup: [HGIEBTSCX.-\_], where
        H is alpha helix, G is 3/10-helix, I is p-helix, E is extended
        strand, B is a residue in an isolated b-bridge, T is a turn, 
        S is a bend, C is a random coil or loop, and X is unknown
        (for instance, a residue that was not resolved in a crystal
        structure). 

\item [\emprog{SA\_cons}]
        Surface accessibility consensus. 0-9, gap symbols, or X are
        accepted as markup. 0 means <10\% accessible residue surface
        area, 1 means <20\%, 9 means <100\%, etc. X means unknown
        structure.
\end{wideitem}

\subsubsection{recognized \#=GR annotations}
\begin{wideitem}
\item [\emprog{SS}]
        Secondary structure consensus. See \prog{\#=GC SS\_cons} above.
\item [\emprog{SA}]
        Surface accessibility consensus. See \prog{\#=GC SA\_cons} above.
\end{wideitem}


\subsection{Count vector files}

\prog{hmmbuild} saves a ``count vector file'' when the \prog{--cfile}
option is invoked. The count vector file contains observed weighted
counts for match emissions, insert emissions, and state transitions.
The intended use of the count vector file is for training mixture
Dirichlet priors (something we do locally), but since it may be useful
for other purposes, the format is documented here.

Each line of the file is an annotated count vector. The format of this
line is:

\begin{wideitem}
\item[\textbf{Vector type}] The first field is a single letter M,
I, or T, specifying whether the line is for a match emission, insert
emission, or transition vector.

\item[\textbf{Counts}] The next several fields are the counts
themselves. 

For match and insert emission vectors, there are either 4 or 20 real
numbers, depending on whether the alignment was DNA/RNA or protein,
respectively; and the counts are in alphabetical order by residue
(``ACGT'' for DNA/RNA, ``AC..WY'' for protein).

For state transition vectors, there are 7 real numbers, in order MM,
MI, MD, IM, II, DM, DD.

The counts are real numbers, not integers, because they're
weighted. Both relative weights (default: tree weights) and absolute
weights (effective sequence number) affect the observed counts. (They
are exactly the numbers used by HMMER before addition of Dirichlet
prior pseudocounts and renormalization.) Options affecting either
relative or absolute weighting will therefore affect the count
vectors. To see unweighted raw count vectors, add \prog{--wnone
--idlevel 1.0} to the \prog{hmmbuild} command line.

\item[\textbf{Alignment name}] If the alignment was in Stockholm
format (for example, a Pfam distribution), the name of the alignment
is recorded in this field. (A count vector file may contain vectors
from a large number of alignments.) If this information is
unavailable, ``-'' appears instead.

\item[\textbf{Alignment column}] An integer indicating which alignment
column this count vector corresponds to. In combination with the
alignment name, this allows you to retrieve other annotation from the
vicinity of this count vector in the original alignment file if you
need to.

\item[\textbf{HMM node}] An integer indicating which HMM node this
vector corresponds to. This number is always $\leq$ the alignment
column index, because some alignment columns are skipped in
constructing an HMM. 

Note that count vectors are only recorded for the alignment columns
that became HMM match states. If you want to collect a count vector
from \emph{every} alignment column, you need to make \prog{hmmbuild}
assign every column to a match state. You can do this by invoking the
\prog{--fast --gapmax 1.0} options to \prog{hmmbuild}.

\item[\textbf{Structure annotation}] The next 2
fields are single characters representing structural annotation
for this column in the alignment, if available. If not,
``-'' characters appear.

The first field is Stockholm format's \verb+#=GC SS_cons+ secondary
structure consensus annotation for the column. This is a single letter
DSSP code.

The second field is Stockholm format's \verb+#=GC SA_cons+ surface
accessibility annotation for the column. This is a single character
0-9 (representing $<$10\% to $<$100\% accessibility), or X for
unknown, or - or . for columns that are gaps in all the known
structures in the alignment.

\item[\textbf{More structure annotation}] Transition vectors
(only) have another two fields of structure annotation for the 
\emph{next} (k+1'th) HMM node. Transition vectors are thought of as
being between the k'th and the k+1'th HMM node, so most applications
would probably want to see the annotation for both.  Note that this
does not necessarily correspond to the annotation on the next
alignment column, because that column is not necessarily assigned to
an HMM node.

\end{wideitem}



