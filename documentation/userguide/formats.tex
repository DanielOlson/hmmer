\chapter{File formats}

\section{HMMER save files}

The file \prog{Demos/rrm.hmm} gives an example of a HMMER ASCII save
file. An abridged version is shown here, where (\ldots) mark deletions
made for clarity and space:

{\small\begin{verbatim}
HMMER2.0
NAME  rrm
DESC  
LENG  72
ALPH  Amino
RF    no
CS    no
MAP   yes
COM   ../src/hmmbuild -F rrm.hmm rrm.slx
COM   ../src/hmmcalibrate rrm.hmm
NSEQ  70
DATE  Wed Jul  8 08:13:25 1998
CKSUM 2768
XT      -8455     -4  -1000  -1000  -8455     -4  -8455     -4 
NULT      -4  -8455
NULE     595  -1558     85    338   -294    453  -1158    (...)
EVD   -49.999123   0.271164
HMM        A      C      D      E      F      G      H      I (...)
         m->m   m->i   m->d   i->m   i->i   d->m   d->d   b->m   m->e
          -21      *  -6129
     1  -1234   -371  -8214  -7849  -5304  -8003  -7706   2384  (...) 1
     -   -149   -500    233     43   -381    399    106   -626  (...)
     -    -11 -11284 -12326   -894  -1115   -701  -1378    -21      * 
     2  -3634  -3460  -5973  -5340   3521  -2129  -4036   -831  (...) 2
     -   -149   -500    233     43   -381    399    106   -626  (...)
     -    -11 -11284 -12326   -894  -1115   -701  -1378      *      * 
(...)
    71  -1165  -4790   -240   -275  -5105  -4306   1035  -2009  (...) 90
     -   -149   -500    233     43   -381    398    106   -626  (...)
     -    -43  -6001 -12336   -150  -3342   -701  -1378      *      * 
    72  -1929   1218  -1535  -1647  -3990  -4677  -3410   1725  (...) 92
     -      *      *      *      *      *      *      *      *  (...) 
     -      *      *      *      *      *      *      *      *      0 
//
\end{verbatim}}

HMMER2 profile HMM save files have a very different format compared to
the previous HMMER1 ASCII formats. The HMMER2 format provides all the
necessary parameters to compare a protein sequence to a HMM, including
the search mode of the HMM (hmmls, hmmfs, hmmsw, and hmms in the old
HMMER1 package), the null (background) model, and the statistics to
evaluate the match on the basis of a previously fitted extreme value
distribution.

The format consists of one or more HMMs. Each HMM starts with the
identifier ``HMMER2.0'' on a line by itself and ends with // on a line
by itself. The identifier allows backward compatibility as the HMMer
software evolves. The closing // allows multiple HMMs to be
concatenated into a single file to provide a database of HMMs.

The format for an HMM is divided into two regions. The first region
contains text information and miscalleneous parameters in a (roughly)
tag-value scheme, akin to EMBL formats. This section is ended by a
line beginning with the keyword \prog{HMM}. The second region is of a
more fixed format and contains the main model parameters. It is ended
by the // that ends the entire definition for a single profile-HMM.

Both regions contain probabilities that are used parameterize the HMM.
These are stored as integers which are related to the probability via
a log-odds calculation. The log-odds score calculation is defined in
\prog{mathsupport.c} and is:

\[
\mbox{score} = (\mbox{\texttt{int}}) \mbox{\texttt{floor}}(0.5 + (\mbox{\texttt{INTSCALE}} * \log_2(\mbox{prob}/\mbox{null-prob})))
\]

so conversely, to get a probability from the scores in an HMM save
file:

\[
\mbox{prob} = \mbox{null-prob} * 2^{\mbox{score}/\mbox{\texttt{INTSCALE}}}
\]

\prog{INTSCALE} is defined in \prog{config.h} as 1000. 

Notice that you must know a null model probability to convert scores
back to HMM probabilities. 

The special case of prob = 0 is translated to ``*'', so a score of *
is read as a probability of 0. Null model probabilities are not
allowed to be 0.

This log-odds format has been chosen because it has a better dynamic
range than storing probabilities as ASCII text, and because the
numbers are more meaningful to a human reader to a certain extent:
positive values means a better than expected probability, and negative
values a worse than expected probability.  However, because of the
conversion from probabilities, it should be noted that {\em you should
not edit the numbers in a HMMER save file directly}. The HMM is a
probabilistic model and expects state transition and symbol emission
probability distributions to sum to one. If you want to edit the HMM,
you must understand the underlying Plan7 probabilistic model, and
ensure the correct summations yourself.

A more detailed description of the format follows.

\subsection{Header section}

In the header section, each line after the initial identifier has a
unique tag of five characters or less. For shorter tags, the remainder
of the five characters is padded with spaces. Therefore the first six
characters of these lines are reserved for the tag and a space. The
remainder of the line starts at the seventh character. The parser does
require this.

\begin{wideitem}

\item [\emprog{HMMER2.0}]
File format version; a unique identifier for this save file format. Used for backwards
compatibility. {\em Not} necessarily the version number of the HMMER
software that generated it; rather, the version number of the last
HMMER that changed the format (i.e., HMMER 2.8 might still be writing
save files that are headed \prog{HMMER2.0}).
\textbf{Mandatory.}

\item [\emprog{NAME  <s>}] Model name; \prog{<s>} is a single word name for the HMM.
No spaces or tabs may occur in the name. By default, \prog{hmmbuild}
sets this using the name of the alignment file, after removing any
file type suffix. For example, an HMM built from the alignment file
\prog{rrm.slx} would be named \prog{rrm} by default.
\textbf{Mandatory.}

\item [\emprog{DESC  <s>}] Description line; \prog{<s>} is a one-line description 
of the HMM. Currently, there is no way to set this! A future extension
to SELEX file format will allow us to pick up the description line
from Pfam.
\textbf{Mandatory.}

\item [\emprog{LENG  <d>}] Model length; \prog{<d>}, a positive nonzero integer, 
is the number of match states in the model.
\textbf{Mandatory.}

\item [\emprog{ALPH  <s>}] Symbol alphabet; \prog{<s>} must be either
\prog{Amino} or \prog{Nucleic}. This determines the symbol alphabet and the
size of the symbol emission probability distributions.  If
\prog{Amino}, the alphabet size is set to 20 and the symbol alphabet
to ``ACDEFGHIKLMNPQRSTVWY'' (alphabetic order). If \prog{Nucleic}, the
alphabet size is set to 4 and the symbol alphabet to ``ACGT''.  Case
insensitive. \textbf{Mandatory.}

\item [\emprog{RF    <s>}] Reference annotation flag; \prog{<s>} must
be either \prog{no} or \prog{yes} (case insensitive). If set to
\prog{yes}, a character of reference annotation is read for each match
state/consensus column in the main section of the file (see below);
else this data field will be ignored.  Reference annotation lines are
currently somewhat inconsistently used. The only major use in HMMER is
to specify which columns of an alignment get turned into match states
when using the
\prog{hmmbuild --hand} manual model construction option. Reference
annotation can only be picked up from SELEX format alignments. See
description of SELEX format for more details on reference annotation
lines. \textbf{Optional}; assumed to be no if not present.

\item [\emprog{CS    <s>}] Consensus structure annotation flag;
\prog{<s>} must be either \prog{no} or \prog{yes} (case insensitive). If set to \prog{yes}, a character
of consensus structure annotation is read for each match
state/consensus column in the main section of the file (see below);
else this data field will be ignored. Consensus structure annotation
lines are currently somewhat inconsistently used.  Consensus structure
annotation can only be picked up from SELEX format alignments.  See
description of SELEX format for more details on consensus structure
annotation lines. \textbf{Optional}; assumed to be no if not present.

\item [\emprog{MAP   <s>}] Map annotation flag;
\prog{<s>} must be either \prog{no} or \prog{yes} (case insensitive).
If set to \prog{yes}, each line of data for the match state/consensus
column in the main section of the file is followed by an extra number.
This number gives the index of the alignment column that the match
state was made from. This information provides a ``map'' of the match
states ($1..M$) onto the columns of the alignment ($1..alen$).  It is
used for quickly aligning the model back to the original alignment,
e.g.\ when using \prog{hmmalign --mapali}. Added in v2.0.1.
\textbf{Optional}; assumed to be no if not present.

\item [\emprog{COM   <s>}] Command line log; \prog{<s>} is a one-line
command. There may be more than one \prog{COM} line per save
file. These lines record the command line for every HMMER command that
modifies the save file. This helps us automatically log Pfam
construction strategies, for example. \textbf{Optional.}

\item [\emprog{CKSUM  <d>}] Training alignment checksum; \prog{<d>} is a nonzero
positive integer. This number is calculated from the training
alignment and stored when \prog{hmmbuild} is used. It is used in
conjunction with the alignment map information to to verify that some
alignment is indeed the alignment that the map is for.  Added in
v2.0.1. \textbf{Optional.}

\item [\emprog{NSEQ  <d>}] Sequence number; \prog{<d>} is a nonzero
positive integer, the number of sequences that the HMM was trained on.
This field is only used for logging purposes.
\textbf{Optional.}

\item [\emprog{DATE  <s>}] Creation date; \prog{<s>} is a date string.
This field is only used for logging purposes.
\textbf{Optional.}

\item [\emprog{XT    <d>*8}] Eight ``special'' transitions for
controlling parts of the algorithm-specific parts of the Plan7 model.
The null probability used to convert these back to model probabilities
is 1.0. The order of the eight fields is N $\rightarrow$ B, N
$\rightarrow$ N, E $\rightarrow$ C, E $\rightarrow$ J, C $\rightarrow$
T, C $\rightarrow$ C, J $\rightarrow$ B, J $\rightarrow$ J.  (Another
way to view the order is as four transition probability distributions
for N,E,C,J; each distribution has two probabilities, the first one
for ``moving'' and the second one for ``looping''.) For an explanation
of these special transitions (and definition of the state names), read
the Plan7 architecture documentation.
\textbf{Mandatory.}

\item [\emprog{NULT  <d> <d>}] The transition probability distribution
for the null model (single G state). The null probability used to
convert these back to model probabilities is 1.0. The order is G
$\rightarrow$ G, G $\rightarrow$ F.
\textbf{Mandatory.}

\item [\emprog{NULE  <d>*K}] The symbol emission probability
distribution for the null model (G state); consists of $K$ (e.g. 4 or
20) integers. The null probability used to convert these back to model
probabilities is $1/K$. (Yes, it's a little weird to have a ``null
probability'' for the null model symbol emission probabilities; this
is strictly an aesthetic decision, so one can look at the null model
and easily tell which amino acids are more common than chance
expectation in the background distribution.) 
\textbf{Mandatory.}

\item [\emprog{EVD   <f> <f>}] The extreme value distribution
parameters $\mu$ and $\lambda$, respectively; both floating point
values. $\lambda$ is positive and nonzero. These values are set when
the model is calibrated with \prog{hmmcalibrate}. They are used to
determine E-values of bit scores. If this line is not present,
E-values are calculated using a conservative analytic upper bound.
\textbf{Optional.}

\item [\emprog{HMM    }] HMM flag line; flags the end of the header
section. Otherwised not parsed. Strictly for human readability, the
symbol alphabet is also shown on this line, aligned to the \prog{NULE}
fields and the fields of the match and insert symbol emission
distributions in the main model. The immediately next line is also an
unparsed human annotation line: column headers for the state
transition probability fields in the main model section that follows.
Both lines are \textbf{mandatory.}

\end{wideitem}

\subsection{Main model section}

All the remaining fields are \textbf{mandatory}, except for the
alignment map.

The first line in the main model section is atypical; it contains
three fields, for transitions from the B state into the first node of
the model. \textit{The only purpose of this line is to set the B
$\rightarrow$ D transition probability}. The first field is the score
for $ 1 - t(B \rightarrow D)$. The second field is always ``*'' (there is no B
$\rightarrow$ I transition). The third field is the score for
$t(B\rightarrow D)$. The null probability used for converting these
scores back to probabilities is 1.0. In principle, only the third
number is needed to obtain $t(B \rightarrow D)$.  In practice, HMMER
reads both the first and the third number, converts them to
probabilities, and renormalizes the distribution to obtain $t(B
\rightarrow D)$. \footnote{OK, it's more complicated than it has to
be. Sometimes you only discover your temporary insanity when you're
trying to document it.}

The remainder of the model has three lines per node, for $M$ nodes
(where $M$ is the number of match states, as given by the \prog{LENG}
line). These three lines are:

\begin{wideitem}

\item [\textbf{Match emission line}] The first field is the node number (1..M).
The HMMER parser verifies this number as a consistency check (it
expects the nodes to come in order). The next $K$ numbers for match
emission scores, one per symbol. The null probability used to convert
them to probabilities is the relevant null model emission probability
calculated from the \prog{NULE} line.

If \prog{MAP} was \prog{yes}, then there is one more number on this
line, representing the alignment column index for this match state.
See \prog{MAP} above for more information about the alignment map, and
also see the man pages for \prog{hmmalign --mapali}.  Added in
v2.0.1. This field is optional, for backwards compatibility with 2.0.

\item [\textbf{Insert emission line}] The first field is a character of
reference annotation (RF), or ``-'' if there is no reference
annotation. The remaining fields are $K$ numbers for insert emission
scores, one per symbol, in alphabetic order. The null probability used
to convert them to probabilities is the relevant null model emission
probability calculated from the \prog{NULE} line.

\item [\textbf{State transition line}] The first field is a character
of consensus structure annotation (CS), or ``-'' if there is no
consensus structure annotation. The remaining 9 fields are state
transition scores. The null probability used to convert them back from
log odds scores to probabilities is 1.0. The order of these scores is
given by the annotation line at the top of the main section: it is M
$\rightarrow$ M, M $\rightarrow$ I, M $\rightarrow$ D; I $\rightarrow$
M, I $\rightarrow$ D; D $\rightarrow$ M, D $\rightarrow$ D; B
$\rightarrow$ M; M $\rightarrow$ E.

\end{wideitem}

The insert emission and state transition lines for the final node $M$
are special.  Node $M$ has no insert state, so all the insert
emissions are given as ``*''. (In fact, this line is skipped by the
parser, except for its RF annotation.) There is also no next node, so
only the B $\rightarrow$ M and M $\rightarrow$ E transitions are
valid; the first seven transitions are always ``*''.  (Incidentally,
the M $\rightarrow$ E transition score for the last node is always 0,
because this probability has to be 1.0.)

Finally, the last line of the format is the ``//'' record separator.

\subsection{Renormalization}

After the parser reads the file and converts the scores back to
probabilities, it renormalizes the probability distributions to sum to
1.0 to eliminate minor rounding/conversion/numerical imprecision
errors.  If you're trying to emulate HMMER save files, it might be
useful to know what HMMER considers to be a probability
distribution. See
\prog{Plan7Renormalize()} in \prog{plan7.c} for the relevant
function.

\begin{wideitem}

\item [\textbf{null emissions}] The $K$ symbol emissions 
given on the \prog{NULE} line.

\item [\textbf{null transitions}] The two null model transitions
given on the \prog{NULT} line.

\item [\textbf{N,E,C,J specials}] Each of the four special states N,E,C,J have two
state transition probabilities (move and loop). All four distributions
are specified on the \prog{XT} line.

\item [\textbf{B transitions}] $M$ B $\rightarrow$
M entry probabilities are given by the 9th field in the state
transition line of each of the $M$ nodes. The B $\rightarrow$ D
transition (from the atypical first line of the main model section) is
also part of this state transition distribution.

\item [\textbf{match transitions}] One distribution of 4 numbers per node; $M \rightarrow M$, 
$M \rightarrow I$, $M \rightarrow D$, and $M \rightarrow E$ (fields 2,
3, 4, and 10 in the state transition line of each node). Note the
asymmetry between B $\rightarrow$ M and M $\rightarrow$ E; entries are
a probability distribution of their own, while exits are not.

\item [\textbf{insert transitions}] One distribution of 2 numbers per node; $I \rightarrow M$, 
$I \rightarrow I$ (fields 5 and 6 of the state transition line of each
node).

\item [\textbf{delete transitions}] One distribution of 2 numbers per
node; $D \rightarrow M$, $D \rightarrow D$ (fields 7 and 8 of the
state transition line of each node).

\item [\textbf{match emissions}] One distribution of $K$ numbers
per node; the $K$ match symbol emissions given on the first line of
each node in the main section.

\item [\textbf{insert emissions}] One distribution of $K$ numbers
per node; the $K$ insert symbol emissions given on the second line of
each node in the main section.

\end{wideitem}

\subsection{Note to developers}

Though I make an effort to keep this documentation up to date, it may
lag behind the code. For definitive answers, please check the parsing
code in \prog{hmmio.c}. The relevant function to see what's being
written is \prog{WriteAscHMM()}. The relevant function to see how it's
being parsed is \prog{read\_asc20hmm()}.


\section {Sequence files}

\subsection{Supported file formats}
 
HMMER can automatically recognize and parse a number of common file
formats. The best supported of these formats are listed below. If you
know your sequence database is in one of these formats, you can use
the file.  If you are typing sequences in manually and want to know
how to format them, see the section of FASTA format below for
unaligned sequences, and the section on SELEX format for alignments.

\textbf{Unaligned sequence formats}
\begin{tabular}{ll}
FASTA     & Pearson FASTA format; BLAST databases \\
SWISSPROT & SWISSPROT protein sequence database\\ 
PIR       & PIR protein sequence database \\
EMBL      & EMBL DNA sequence database \\
GenBank   & GenBank DNA database flat files\\
GCGdata   & Wisconsin GCG sequence database format \\
GCG       & Wisconsin GCG single sequence format \\
\end{tabular}

\textbf{Multiple sequence alignment formats}
\begin{tabular}{ll}
MSF     &   GCG alignment format \\
CLUSTAL &   CLUSTALW and CLUSTALV format \\
SELEX   &   My annotated format (see below)\\
\end{tabular}

Alignment formats are read as if they were multiple unaligned
sequences by programs doing sequential, database-style access.

There is no provision for enforcing that single unaligned sequence
formats (i.e. GCG unaligned sequence format) are single sequence
only. HMMER will happily try to read more than one sequence if your
file contains more than one. However, this may not give the results
you expected.

Staden ``experiment file'' format is parsed using the EMBL file
parser, but this functionality is relatively unsupported. There is one
wrinkle in this. Staden experiment files use '-' characters to
indicate 'N' -- i.e., that a base is present in a sequence read, but
its identity is unknown. Therefore, the software replaces any '-' in
an EMBL sequence with an 'N'. Sometimes people use the unaligned
formats to distribute aligned sequences by including gap
characters. If EMBL files are used i this way for aligned strings,
they must use a different character than '-' to indicate gaps.

\subsection{FASTA unaligned sequence format}

An example of a simple FASTA file: 

\begin{verbatim}
> seq1 This is the description of my first sequence.
AGTACGTAGTAGCTGCTGCTACGTGCGCTAGCTAGTACGTCA
CGACGTAGATGCTAGCTGACTCGATGC
> seq2 This is a description of my second sequence.
CGATCGATCGTACGTCGACTGATCGTAGCTACGTCGTACGTAG
CATCGTCAGTTACTGCATGCTCG
\end{verbatim}

FASTA is probably the simplest of formats for unaligned sequences.
FASTA files are easily created in a text editor.  Each sequence is
preceded by a line starting with \verb+>+. The first word on this line
is the name of the sequence. The rest of the line is a description of
the sequence (free format). The remaining lines contain the sequence
itself. You can put as many letters on a sequence line as you want.

Blank lines in a FASTA file are ignored, and so are spaces or other
gap symbols (dashes, underscores, periods) in a sequence. Any other
non-amino or non-nucleic acid symbols in the sequence should produce
an appropriately strident string of warnings on yur terminal screen
when you try to use the file.

\subsection{SELEX alignment format}

An example of a simple SELEX alignment file:

\begin{verbatim}
# Example selex file

seq1     ACGACGACGACG.
seq2     ..GGGAAAGG.GA
seq3     UUU..AAAUUU.A

seq1  ..ACG
seq2  AAGGG
seq3  AA...UUU
\end{verbatim}

SELEX is an interleaved multiple alignment format that arose as an
intuitive format that was easy to write and manipulate manually with a
text editor like emacs. It is usually easy to convert other alignment
formats into SELEX format, even with a couple of lines of Perl, but it
can be harder to go the other way, since SELEX is more free-format
than other alignment formats. For instance, GCG's MSF format and the
output of the CLUSTALV multiple alignment program are similar
interleaved formats that can be converted to SELEX just by stripping a
small number of non-sequence lines out. Because SELEX evolved to
accomodate different user input styles, it is very tolerant of various
inconsistencies such as different gap symbols, varying line lengths,
etc.

Each line contains a name, followed by the aligned sequence. A space,
dash, underscore, or period denotes a gap. If the alignment is too
long to fit on one line, the alignment is split into multiple blocks,
separated by blank lines. The number of sequences, their order, and
their names must be the same in every block (even if a sequence has no
residues in a given block!) Other blank lines are ignored. You can add
comments to the file on lines starting with a \verb+#+.

SELEX, by the way, stands for ``Systematic Evolution of Ligands by
Exponential Enrichment'' -- it refers to the Tuerk and Gold technology
for evolving families of small RNAs for particular functions
\cite{Tuerk90b}. SELEX files were what we used to keep track of
alignments of these small RNA families.

As the format evolved, more features have been added. To maintain
compatibility with past alignment files, the new features are added
using a reserved comment style. You don't have to worry about adding
these extra information lines. They are generally the province of
automated SELEX-generating software, such as my \prog{koala} sequence
alignment editor or the \prog{COVE} and HMMER sequence analysis
packages. This extra information includes consensus and individual RNA
or protein secondary structure, sequence weights, a reference
coordinate system for the columns, and database source information
including name, accession number, and coordinates (for subsequences
extracted from a longer source sequence) See below for details.

\subsubsection {Detailed specification of a SELEX file}

\begin{enumerate}
\item
Any line beginning with a \verb+#=+ as the first two characters is a
machine comment.  \verb+#=+ comments are reserved for parsed data
about the alignment. Usually these features are maintained by software
such as the {\tt koala} editor, not by hand. The format of \verb+#=+
lines is usually quite specific, since they must be parsed by the
file-reading software.

\item
All other lines beginning with a \verb+%+ or \verb+#+ as the first
character are user comments.  User comments are ignored by all
software. Anything may appear on these lines. Any number of comments
may be included in a SELEX file, and at any point.

\item
Lines of data consist of a name followed by a sequence. The total
length of the line must be smaller than 1024 characters.

\item
Names must be a single word. Any non-whitespace characters are
accepted.  No spaces are tolerated in names: names MUST be a
single word. Names must be less than 32 characters long.

\item In the sequence, any of the characters \verb+-_.+ or a space are
recognized as gaps. Gaps will be converted to a '.'. Any other
characters are interpreted as sequence.  Sequence is
case-sensitive. There is a common assumption by my software that
upper-case symbols are used for consensus (match) positions and
lower-case symbols are used for inserts. This language of ``match''
versus ``insert'' comes from the hidden Markov model formalism
\cite{Krogh94}. To almost all of my software, this isn't important,
and it immediately converts the sequence to all upper-case after it's
read.

\item
Multiple different sequences are grouped in a block of data lines.
Blocks are separated by blank lines. No blank lines are tolerated
between the sequence lines in a block. Each block in a multi-block
file of a long alignment must have its sequences in the same order in
each block. The names are checked to verify that this is the case; if
not, only a warning is generated. (In manually constructed files, some
users may wish to use shorthand names in subsequent blocks after an
initial block with full names -- but this isn't recommended.)
\end{enumerate}

\subsubsection {Optional annotation}

\subsubsection {Secondary structure}

I use one-letter codes to indicate secondary structures. Secondary
structure strings are aligned to sequence blocks just like additional
sequences.

For RNA secondary structure, the symbols \verb+>+ and \verb+<+ are
used for base pairs (pairs point at each other).  \verb-+- indicate
definitely single-stranded positions, and any gap symbol indicates
unassigned bases or single-stranded positions.  This description
roughly follows \cite{Konings89}.  For protein secondary structure, I
use {\tt E} to indicate residues in $\beta$-sheet, {\tt H} for those
in $\alpha$-helix, {\tt L} for those in loops, and any gap symbol for
unassigned or unstructured residues.

RNA pseudoknots are represented by alphabetic characters, with upper
case letters representing the 5' side of the helix and lower case
letters representing the 3' side. Note that this restricts the
annotation to a maximum of 26 pseudoknots per sequence.

Lines beginning with \verb+#=SS+ or \verb+#=CS+ are individual or
consensus secondary structure data, respectively.  \verb+#=SS+
individual secondary structure lines must immediately follow the
sequence they are associated with.  There can only be one \verb+#=SS+
per sequence. All, some, or none of the sequences may have \verb+#=SS+
annotation.

\verb+#=CS+ consensus secondary structure predictions precede all the
sequences in each block. There can only be one \verb+#=CS+ per file.

\subsubsection {Reference coordinate system}

Alignments are usually numbered by some reference coordinate system,
often a canonical molecule. For instance, tRNA positions are numbered
by reference to the positions of yeast tRNA-Phe.

A line beginning with \verb+#=RF+ preceding the sequences in a block
gives a reference coordinate system. Any non-gap symbol in the
\verb+#=RF+ line indicates that sequence positions in its columns are
numbered. For instance, the \verb+#=RF+ lines for a tRNA alignment
would have 76 non-gap symbols for the canonical numbered columns; they
might be the aligned tRNA-Phe sequence itself, or they might be just
X's.

\subsubsection {Sequence header}

Additional per-sequence information can be placed in a header before
any blocks appear. These lines, one per sequence and in exactly the
same order as the sequences appear in the alignment, are formatted
like 

{\small \begin{verbatim}
#=SQ <name> <wgt> <source> <accession> <start..stop::orig length> <desc>
\end{verbatim}}

This information includes a sequence weight (for compensating for
biased representation of subfamilies of sequences in the alignment);
source information, if the sequence came from a database, consisting
of identifier, accession number, and source coordinates; and a
description of the sequence.

If a \verb+#=SQ+ line is present, all the fields must be present on
each line and one \verb+#=SQ+ line must be present for each sequence.
If no information is available for a field, use '-' for all the fields
except the source coordinates, which would be given as '0'.

\subsubsection {Author}

The first non-comment, non-blank line of the file may be a \verb+#=AU+
``author'' line. There is a programmatic interface for
alignment-generating programs to record a short comment like \\
\verb+11 November 1993, by Feng-Doolittle v. 2.1.1+, \\
and this comment will be
recorded on the \verb+#=AU+ line by \verb+WriteSELEX()+.


\subsubsection{An example SELEX file with annotation}

Here's an example SELEX file with examples of all the optional fields.
The sequences are evolved RNA ligands for the phage R17 coat protein
\cite{Schneider92}.

\begin{verbatim}

#=AU COVE 2.2.3

#=SQ lig28 1.0 - - 1..29:29 R17 coat protein ligand 28
#=SQ lig1  1.0 - - 1..17:17 R17 coat protein ligand 1
#=SQ lig2  1.0 - - 1..29:29 R17 coat protein ligand 2

#=RF         ***A** loop *****
#=CS  .......>>>+>> ++++ <<<<<....... 
lig28 GGAGUAAGAUAGC AUCA GCAUCUUGUUCC
#=SS   >>>>>>>>>+>> ++++ <<<<<<<<<<<<
lig1        GUUCACC AUCA GGGGAC
#=SS        >>>>+>> ++++ <<<<<<
lig2  AUGGAUGCGCACC AUCA GGGCGUAUCUAU
#=SS  >>>>>>>>>>+>> ++++ <<<<<<<<<<<<
\end{verbatim}

