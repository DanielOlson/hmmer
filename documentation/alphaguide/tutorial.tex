
\section{Tutorial}
\label{section:tutorial}

Here's a tutorial walk-through of some small projects with
HMMER3. This should suffice to get you oriented to a ``safe path''
through HMMER3 alpha test code that should work as advertised -- before
you start boldly exploring later-to-be-documented command line options
that might or might not be doing anything sensible yet.


\subsection{Files used in the tutorial}

The subdirectory \prog{/tutorial} in the HMMER distribution contains the
files used in the tutorial, as well as a number of examples of various
file formats that HMMER reads. The important files for the tutorial
are:


\begin{wideitem}
\item[\emprog{globins4.sto}] An example alignment of four globin sequences, in
  Stockholm format. This alignment is a subset of a famous old
  published structural alignment from Don Bashford \citep{Bashford87}.
%
\item[\emprog{globins4.hmm}] An example profile HMM file, built from
  \prog{globins4.out}, in HMMER3 ASCII text format.
%
\item[\emprog{globins4.out}] An example \prog{hmmsearch} output file that results
  from searching the \prog{globins4.hmm} against Uniprot 7.0.
%
\item[\emprog{fn3.sto}] An example alignment of 106 fibronectin type III
  domains. This is the Pfam 22.0 \prog{fn3} seed alignment. It provides an
  example of a Stockholm format with more complex annotation. We'll also use
  it for an example of \prog{hmmsearch} analyzing sequences containing multiple
  domains.
%
\item[\emprog{fn3.hmm}] A profile HMM created from \prog{fn3.sto} by
  \prog{hmmbuild}.
%
\item[\emprog{7LESS\_DROME}] A FASTA file containing the sequence of
  the \emph{Drosophila} Sevenless protein, a receptor tyrosine kinase
  whose extracellular region is thought to contain seven fibronectin
  type III domains. 
%
\item[\emprog{fn3.out}] Output of \prog{hmmsearch fn3.hmm 7LESS\_DROME}.
%
\item[\emprog{Pkinase.sto}] The Pfam 22.0 {Pkinase} seed alignment of
  protein kinase domains.
%
\item[\emprog{minifam}] An example HMM flatfile database, containing
  three models: \prog{globins4}, \prog{fn3}, and \prog{Pkinase}.
%
\item[\emprog{minifam.h3\{m,i,f,p\}}] Binary compressed files
  corresponding to \prog{minifam}, produced by \prog{hmmpress}.
%
\item[\emprog{HBB\_HUMAN}] A FASTA file containing the sequence of
  human $\beta-$hemoglobin, used as an example query for \prog{phmmer}.
\end{wideitem}



\subsection{Searching a sequence database with a single profile HMM}

\subsubsection{Step 1: build a profile HMM with hmmbuild}

HMMER starts with a multiple sequence alignment file that you
provide. Currently HMMER3 only reads Stockholm
alignments.\footnote{I'm lying. It can read more. I just don't trust
its other parsers yet.} The file \prog{tutorial/globins4.sto} is an
example of a simple Stockholm file. It looks like this:

\begin{sreoutput}
# STOCKHOLM 1.0

HBB_HUMAN   ........VHLTPEEKSAVTALWGKV....NVDEVGGEALGRLLVVYPWTQRFFESFGDLSTPDAVMGNPKVKAHGKKVL
HBA_HUMAN   .........VLSPADKTNVKAAWGKVGA..HAGEYGAEALERMFLSFPTTKTYFPHF.DLS.....HGSAQVKGHGKKVA
MYG_PHYCA   .........VLSEGEWQLVLHVWAKVEA..DVAGHGQDILIRLFKSHPETLEKFDRFKHLKTEAEMKASEDLKKHGVTVL
GLB5_PETMA  PIVDTGSVAPLSAAEKTKIRSAWAPVYS..TYETSGVDILVKFFTSTPAAQEFFPKFKGLTTADQLKKSADVRWHAERII

HBB_HUMAN   GAFSDGLAHL...D..NLKGTFATLSELHCDKL..HVDPENFRLLGNVLVCVLAHHFGKEFTPPVQAAYQKVVAGVANAL
HBA_HUMAN   DALTNAVAHV...D..DMPNALSALSDLHAHKL..RVDPVNFKLLSHCLLVTLAAHLPAEFTPAVHASLDKFLASVSTVL
MYG_PHYCA   TALGAILKK....K.GHHEAELKPLAQSHATKH..KIPIKYLEFISEAIIHVLHSRHPGDFGADAQGAMNKALELFRKDI
GLB5_PETMA  NAVNDAVASM..DDTEKMSMKLRDLSGKHAKSF..QVDPQYFKVLAAVIADTVAAG.........DAGFEKLMSMICILL

HBB_HUMAN   AHKYH......
HBA_HUMAN   TSKYR......
MYG_PHYCA   AAKYKELGYQG
GLB5_PETMA  RSAY.......
//
\end{sreoutput}


Most popular alignment formats are similar block-based formats, and
can be turned into Stockholm format with a little editing or
scripting. Don't forget the \prog{\# STOCKHOLM 1.0} line at the start
of the alignment, nor the \prog{//} at the end. Stockholm alignments
can be concatenated to create an alignment database flatfile
containing many alignments.


The \prog{hmmbuild} command builds a profile HMM from an alignment (or
HMMs for each of many alignments in a Stockholm file), and saves the
HMM(s) in a file. For example, type:

\user{hmmbuild globins4.hmm tutorial/globins4.sto}

and you'll see some output that looks like:

\begin{sreoutput}
# hmmbuild :: profile HMM construction from a multiple sequence alignment
# HMMER 3.0a1 (January 2009); http://hmmer.org/
# Copyright (C) 2008 Howard Hughes Medical Institute.
# Freely distributed under the GNU General Public License (GPLv3).
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# input alignment file:             globins4.sto
# output HMM file:                  globins4.hmm
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# idx name                  nseq  alen  mlen  description
#---- -------------------- ----- ----- -----  -----------
1     globins4                 4   171   148

# CPU time: 0.37u 0.00s 00:00:00.37 Elapsed: 00:00:01
\end{sreoutput}


If your input file had contained more than one alignment, you'd get
one line of output for each model. For instance, a single
\prog{hmmbuild} command suffices to turn a Pfam seed alignment
flatfile (such as \prog{Pfam-A.seed}) into a profile HMM flatfile
(such as \prog{Pfam.hmm}).

The information on these lines is almost self-explanatory. The
\prog{globins4} alignment consisted of 4 sequences with 171 aligned
columns. HMMER turned it into a model of 148 consensus positions,
which means it defined 23 gap-containing alignment columns to be
insertions relative to consensus.

This output format is rudimentary.  HMMER3 knows quite a bit more
information about what it's done to build this HMM. Some of this
information is likely to be useful to you, the user. As H3 testing and
development proceeds, we're likely to expand the amount of data that
\prog{hmmbuild} reports.

The new HMM was saved to \prog{globins4.hmm}. If you were to look at
this file (and you don't have to -- it's intended for HMMER's
consumption, not yours), you'd see something like:

\begin{sreoutput}
HMMER3/a [3.0a1 | January 2009]
NAME  globins4
LENG  148
ALPH  amino
RF    no
CS    no
MAP   yes
DATE  Fri Jan  9 11:58:38 2009
NSEQ  4
EFFN  0.962402
CKSUM 247350336
STATS LOCAL     VLAMBDA 0.709641
STATS LOCAL         VMU -9.735310
STATS LOCAL        FTAU -4.078249
HMM          A        C        D        E        F        G        H        I    ...   W        Y
            m->m     m->i     m->d     i->m     i->i     d->m     d->d
  COMPO   2.37156  4.52373  2.96553  2.70511  3.20656  3.01795  3.40301  2.91175 ... 4.55553  3.62859
          2.68606  4.42250  2.77504  2.73148  3.46379  2.40510  3.72519  3.29311 ... 4.58502  3.61528
          0.34002  1.27034  4.89152  1.48427  0.25705  0.00000        *
      1   2.62751  4.46690  3.32467  2.83143  3.63123  3.49811  2.73769  3.02526 ... 5.05801  3.76691     10 - -
          2.68618  4.42225  2.77519  2.73123  3.46354  2.40513  3.72494  3.29354 ... 4.58477  3.61503
          0.02324  4.16917  4.89152  0.61958  0.77255  0.48576  0.95510
...
    148   2.93123  5.12550  3.29461  2.66392  4.49241  3.60571  2.49799  3.89555 ... 5.42846  4.19770    165 - -
          2.68633  4.42241  2.77535  2.73099  3.46369  2.40470  3.72510  3.29370 ... 4.58492  3.61421
          0.20946  1.66612        *  1.49476  0.25399  0.00000        *
//
\end{sreoutput}

The HMMER3 ASCII save file format is defined in
Section~\ref{section:formats}.

If you're used to HMMER2, now you may be expecting to calibrate the
model with H2's \prog{hmmcalibrate} program. HMMER3 models no longer
need a separate calibration step. We've figured out how to calculate
the necessary parameters rapidly, bypassing the need for costly
simulation \citep{Eddy08}. The determination of the statistical
parameters is part of \prog{hmmbuild}. These are the parameter values
$\lambda$, $\mu$, and $\tau$ on the lines marked \prog{STATS}.

You also may be expecting to need to configure the model's alignment
mode, as in HMMER2's \prog{hmmbuild -f} option for building local
``fragment search'' alignment models, for example. HMMER3's
\prog{hmmbuild} does not have these options. \prog{hmmbuild} builds a
``core profile'', which the search and alignment programs configure as
they need to. At least for the moment, they always configure for local
alignment.


\subsubsection{Step 2: search the sequence database with hmmsearch}

Presumably you have a sequence database to search. Here I'll use the
Uniprot 7.0 Swissprot FASTA format flatfile (not provided in the
tutorial, because of its large size), \prog{uniprot\_sprot.fasta}.  If
you don't have a sequence database handy, run your example search
against \prog{tutorial/globins45.fa} instead, which is a FASTA format
file containing 45 globin sequences.

\prog{hmmsearch} accepts any FASTA file as input. It also accepts
EMBL/Uniprot text format. It will automatically determine what format
your file is in; you don't have to say. An example of searching a
sequene database with our \prog{globins4.hmm} model would look like:

\user{hmmsearch globins4.hmm uniprot\_sprot.fasta > globins4.out}

Depending on the database you search, the output file
\prog{globins4.out} should look more or less like the example of a
Uniprot search output provided in \prog{tutorial/globins4.out}.

The first section is the \emph{header} that tells you what program you
ran, on what, and with what options:

\begin{sreoutput}
# hmmsearch :: search profile HMM(s) against a sequence database
# HMMER 3.0a1 (January 2009); http://hmmer.org/
# Copyright (C) 2008 Howard Hughes Medical Institute.
# Freely distributed under the GNU General Public License (GPLv3).
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# query HMM file:                  globins4.hmm
# target sequence database:        uniprot_sprot.fasta
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Query:       globins4  [M=148]
Scores for complete sequences (score includes all domains):
\end{sreoutput}

The second section is the \emph{ sequence top hits} list. It is a list
of ranked top hits (sorted by E-value, most significant hit first),
formatted in a BLAST-like style:

\begin{sreoutput}
 --- full sequence ---   --- best 1 domain ---    -#dom-
  E-value  score  bias    E-value  score  bias    exp  N  Sequence    Description
  ------- ------ -----    ------- ------ -----   ---- --  --------    -----------
  2.1e-64  219.4   0.1    2.3e-64  219.2   0.0    1.0  1  HBB_GORGO   (P02024) Hemoglobin beta subunit
  2.8e-64  219.0   3.2    3.1e-64  218.8   2.2    1.0  1  MYG_PHYCA   (P02185) Myoglobin
    3e-64  218.9   0.0    3.4e-64  218.7   0.0    1.0  1  HBB_HUMAN   (P68871) Hemoglobin beta subunit
    3e-64  218.9   0.0    3.4e-64  218.7   0.0    1.0  1  HBB_PANPA   (P68872) Hemoglobin beta subunit
    3e-64  218.9   0.0    3.4e-64  218.7   0.0    1.0  1  HBB_PANTR   (P68873) Hemoglobin beta subunit
    5e-64  218.2   0.1    5.5e-64  218.0   0.1    1.0  1  HBB_HYLLA   (P02025) Hemoglobin beta subunit
  7.7e-64  217.5   0.2    8.6e-64  217.4   0.1    1.0  1  HBB_COLBA   (P02033) Hemoglobin beta subunit
\end{sreoutput}

The last two columns, obviously, are the name of each target sequence
and optional description.

The most important number here is the first one, the \emph{sequence
E-value}. This is the statistical significance of the match to this
sequence: the number of hits we'd expect to score this highly in a
database of this size if the database contained only nonhomologous
random sequences. The lower the E-value, the more significant the hit.

The E-value is based on the \emph{sequence bit score}, which is the
second number. This is the log-odds score for the complete sequence.
Some people like to see a bit score instead of an E-value, because the
bit score doesn't depend on the size of the sequence database, only on
the profile HMM and the target sequence.

The next number, the \emph{bias}, is a correction term for biased
sequence composition that's been applied to the sequence bit
score.\footnote{The method that HMMER3 uses to compensate for biased
composition is unpublished, and different from HMMER2. We will write
it up when there's a chance.} The only time you really need to pay
attention to this value is when it's large, and on the same order of
magnitude as the sequence bit score. This might be a sign that the
target sequence isn't really a homolog, but merely shares a similar
strong biased composition with the query model.  The biased
composition correction usually works well, but occasionally will not
knock down a falsely ``significant'' nonhomologous hit as far as it
should.

The next three numbers are again an E-value, score, and bias, but only
for the single best-scoring domain in the sequence, rather than the
sum of all its identified domains. The rationale for this isn't
apparent in the globin example, because all the globins in this
example consist of only a single globin domain. So let's set up a
second example, using a model of a single domain that's commonly found
in multiple domains in a single sequence. Build a fibronectin type III
domain model using the \prog{tutorial/fn3.sto} alignment (this happens
to be a Pfam seed alignment; it's a good example of an alignment with
complex Stockholm annotation). Then use that model to analyze the
sequence \prog{tutorial/7LESS\_DROME}, the \emph{Drosophila} Sevenless
receptor tyrosine kinase:

\user{hmmbuild fn3.hmm tutorial/fn3.sto} \\
\user{hmmsearch fn3.hmm tutorial/7LESS\_DROME > fn3.out}

An example of what that output file will look like is provided in
\prog{tutorial/fn3.out}. The sequence top hits list says:

\begin{sreoutput}
 --- full sequence ---   --- best 1 domain ---    -#dom-
  E-value  score  bias    E-value  score  bias    exp  N  Sequence    Description
  ------- ------ -----    ------- ------ -----   ---- --  --------    -----------
  2.5e-56  174.0   0.1    2.1e-15   43.3   0.4    9.6  9  7LESS_DROME RecName: Full=Protein sevenless; 
\end{sreoutput}

OK, now let's pick up the explanation where we left off. The total
sequence score of 174.0 sums up \emph{all} the fibronectin III domains
that were found in the \prog{7LESS\_DROME} sequence. The ``single best
dom'' score and E-value are the bit score and E-value as if the target
sequence only contained the single best-scoring domain, without this
summation.

The idea is that we might be able to detect that a sequence is a
member of a multidomain family because it contains multiple
weakly-scoring domains, even if no single domain is solidly
significant on its own.  On the other hand, if the target sequence
happened to be a piece of junk consisting of a set of identical
internal repeats, and one of those repeats accidentially gives a weak
hit to the query model, all the repeats will sum up and the sequence
score might look ``significant'' (which mathematically, alas, is the
correct answer: the null hypothesis we're testing against is that the
sequence is a \emph{random} sequence of some base composition, and a
repetitive sequence isn't random).

So operationally:
\begin{itemize}
\item if both E-values are significant ($<<1$), the sequence is likely
      to be homologous to your query.
\item if the full sequence E-value is significant but the single best domain
      E-value is not, the target sequence is probably a multidomain remote 
      homolog; but be wary, and watch out for the case where it's just a repetitive
      sequence.
\end{itemize}

OK, the sharp eyed reader asks, if that's so, then why in the globin4
output (all of which have only a single domain) do the full sequence
bit scores and best single domain bit scores not exactly agree? For
example, the top ranked hit, \prog{HBB\_GORGO} (gorilla
$\beta$-hemoglobin) has a full sequence score of 219.4 and a single
best domain score of 219.2. What's going on? What's going on is that
the position and alignment of that domain is uncertain -- in this
case, only very slightly so, but nonetheless uncertain. The full
sequence score is summed over all possible alignments of the globin
model to the \prog{HBB\_GORGO} sequence. When HMMER3 identifies
domains, it identifies what it calls an \textbf{envelope} bounding
where the domain's alignment most probably lies. (More on this later,
when we discuss the reported coordinates of domains and alignments in
the next section of the output.) The ``single best dom'' score is
calculated after the domain envelope has been defined, and the
summation is restricted only to the ensemble of possible alignments
that lie within the envelope. The fact that the two scores are
slightly different is therefore telling you that there's a small
amount of probability (uncertainty) that the domain lies somewhat
outside the envelope bounds that HMMER has selected.

The two columns headed \prog{\#doms} are two different estimates of
the number of distinct domains that the target sequence contains. The
first, the column marked \prog{exp}, is the \emph{expected} number of
domains according to HMMER's statistical model. It's an average,
calculated as a weighted marginal sum over all possible
alignments. Because it's an average, it isn't necessarily a round
integer. The second, the column marked \prog{N}, is the number of
domains that HMMER3's domain postprocessing and annotation pipeline
finally decided to identify, annotate, and align in the target
sequence. This is the number of alignments that will show up in the
domain report later in the output file.

These two numbers should be about the same. Rarely, you might see that
they're wildly different, and this would usually be a sign that the
target sequence is so highly repetitive that it's confused the H3
domain postprocessors. Such sequences aren't likely to show up as
significant homologs to any sensible query in the first place.

The sequence top hits output continues until it runs out of sequences
to report. By default, the report includes all sequences with an
E-value of 10.0 or less. 

Then comes the third output section, which starts with

\begin{sreoutput}
Domain and alignment annotation for each sequence:
\end{sreoutput}

Now for each sequence in the top hits list, there will be a section 
containing a table of where HMMER3 thinks all the domains are,
followed by the alignment inferred for each domain. Let's use the
\prog{fn3} vs. \prog{7LESS\_DROME} example, because it contains lots
of domains, and is more interesting in this respect than the globin4
output.  The domain table for \prog{7LESS\_DROME} looks like:

\begin{sreoutput}
>> 7LESS_DROME  RecName: Full=Protein sevenless;          EC=2.7.10.1;
     # bit score    bias    E-value ind Evalue hmm from   hmm to    ali from   ali to    env from   env to    ali-acc
   --- --------- ------- ---------- ---------- -------- --------    -------- --------    -------- --------    -------
     1      -2.3     0.0       0.37       0.37       60       72 ..      396      408 ..      395      410 ..    0.86
     2      42.0     0.0    5.2e-15    5.2e-15        2       83 ..      439      520 ..      437      521 ..    0.95
     3      15.1     0.0    1.3e-06    1.3e-06       14       82 ..      837      911 ..      827      914 ..    0.82
     4       3.6     0.0     0.0055     0.0055        6       35 ..     1205     1235 ..     1202     1258 ..    0.81
     5      22.9     0.0    4.8e-09    4.8e-09       13       79 ..     1312     1380 ..     1304     1385 ..    0.81
     6      -0.6     0.0       0.11       0.11       57       72 ..     1754     1769 ..     1747     1769 ..    0.87
     7      43.3     0.4    2.1e-15    2.1e-15        1       82 [.     1799     1888 ..     1799     1891 ..    0.89
     8      19.2     0.0    7.2e-08    7.2e-08        6       73 ..     1904     1966 ..     1900     1976 ..    0.90
     9      12.0     0.0    1.2e-05    1.2e-05        1       77 [.     1993     2098 ..     1993     2107 ..    0.74
\end{sreoutput}

Domains are reported in the order they appear in the sequence, not in
order of their significance.

The bit score and bias values are as described above for sequence
scores, but are the score of just one domain's envelope. 

The first of the two E-values is the \textbf{conditional
E-value}. This is an odd number, and it's not even clear we're going
to keep it. Pay attention to what it means! It is an attempt to
measure the statistical significance of each domain, \emph{given that
we've already decided that the target sequence is a true homolog}.  It
is the expected number of \emph{additional} domains we'd find with a
domain score this big in the set of sequences reported in the top hits
list, if those sequences consisted only of random nonhomologous
sequence outside the region that sufficed to define them as homologs. 

The second number is the \textbf{independent E-value}: the
significance of the sequence in the \emph{whole} database search, if
this were the only domain we had identified. It's exactly the same as
the ``best 1 domain'' E-value in the sequence top hits list.

The different between the two E-values is not apparent in the
\prog{7LESS\_DROME} example because in both cases, the size of the
search space as 1 sequence. There's a single sequence in the target
sequence database (that's the size of the search space that the
independent/best single domain E-value depends on). There's one
sequence reported as a putative homolog in the sequence top hits list
(that's the size of the search space that the conditional E-value
depends on). A better example is to see what happens when we search
Uniprot (7.0 contains 207132 sequences) with the \prog{fn3} model:

\user{hmmsearch fn3.hmm uniprot\_sprot.fasta}

(If you don't have Uniprot and can't run a command like this, don't
worry about it - I'll show the relevant bits here.) Now the domain
report for \prog{7LESS\_DROME} looks like:

\begin{sreoutput}
>> 7LESS_DROME  (P13368) Sevenless protein (EC 2.7.1.112)
     # bit score    bias    E-value ind Evalue hmm from   hmm to    ali from   ali to    env from   env to    ali-acc
   --- --------- ------- ---------- ---------- -------- --------    -------- --------    -------- --------    -------
     1      -2.3     0.0      2e+02    7.7e+04       60       72 ..      396      408 ..      395      410 ..    0.86
     2      42.0     0.0    2.7e-12    1.1e-09        2       83 ..      439      520 ..      437      521 ..    0.95
     3      15.1     0.0    0.00071       0.28       14       82 ..      837      911 ..      827      914 ..    0.82
     4       3.6     0.0        2.9    1.1e+03        6       35 ..     1205     1235 ..     1202     1258 ..    0.81
     5      22.9     0.0    2.6e-06      0.001       13       79 ..     1312     1380 ..     1304     1385 ..    0.81
     6      -0.6     0.0         59    2.3e+04       57       72 ..     1754     1769 ..     1747     1769 ..    0.87
     7      43.3     0.4    1.1e-12    4.3e-10        1       82 [.     1799     1888 ..     1799     1891 ..    0.89
     8      19.2     0.0    3.8e-05      0.015        6       73 ..     1904     1966 ..     1900     1976 ..    0.90
     9      12.0     0.0     0.0065        2.6        1       77 [.     1993     2098 ..     1993     2107 ..    0.74
\end{sreoutput}

Notice that everything's the same (it's the same target sequence,
after all) \emph{except} those E-values. The independent E-value is
calculated assuming a search space of all 207132 sequences. For
example, look at domain number 7, the highest scoring domain. When we
only looked at a single sequence, its score of 43.3 bits has an
E-value of 2.1e-15. When we search a database of 207132 sequences, a
hit scoring 43.3 bits would be expected to happen 207132 times as
often: 2.1e-15 $\times$ 207132 $=$ 4.3e-10. In this Uniprot search,
530 sequences were reported in the top hits list (with E-values $\leq
10$). If we were to assume that all 530 are true homologs, x out the
domain(s) that made us think that, and then went looking for
\emph{additional} domains in those 530 sequences, we'd be searching a
smaller database of 530 sequences: the expected number of times we'd
see a hit of 43.3 bits or better is now 2.6e-15 $\times$ 530 $=$
1.1e-12.

So, operationally:

\begin{itemize}
\item If the independent E-value is significant ($<<1$), that means
that even this single domain \emph{by itself} is such a strong hit
that it suffices to identify the sequence as a significant homolog
with respect to the size of the entire original database search. You
can be confident that this is a homologous domain.

\item Once there's one or more high-scoring domains in the sequence
already, sufficient to decide that the sequence contains homologs of
your query, you can look (with some caution) at the conditional
E-value to decide the statistical significance of additional
weak-scoring domains.
\end{itemize}

In this case, for example, I'd be pretty sure of four of the domains
(2, 5, 7, and 8), each of which has a strong enough independent
E-value to declare \emph{7LESS\_DROME} to be an
fnIII-domain-containing protein. Domains 3 and 9 wouldn't be
significant if they were all I saw in the sequence, but in a small
search space, their conditional E-values indicate that they are
probably also fn3 domains. Domains 1, 4, and 6 are too weak to be sure
of, from this search alone, but would be something to pay attention to
and follow up on.

The next four columns give the endpoints of the reported local
alignment with respect to both the query model (``hmm from'' and ``hmm
to'') and the target sequence (``ali from'' and ``ali to''). 

It's not immediately easy to tell from the ``to'' coordinate whether
the alignment ended internally in the query or target, versus ran all
the way (as in a full-length global alignment) to the end(s). To make
this more readily apparent, with each pair of query and target
endpoint coordinates, there's also a little symbology. \prog{..}
meaning both ends of the alignment ended internally, and \prog{[]}
means both ends of the alignment were full-length flush to the ends of
the query or target, and \prog{[.} and \prog{.]} mean only the left or
right end was flush/full length. 

The next two columns (``env from'' and ``env to'') define the
\emph{envelope} of the domain's location on the target sequence.  The
envelope is almost always a little wider than what HMMER chooses to
show as a reasonably confident alignment. As mentioned earlier, the
envelope represents a subsequence that encompasses most of the
posterior probability for a given homologous domain, even if precise
endpoints are only fuzzily inferrable. You'll notice that for higher
scoring domains, the coordinates of the envelope and the inferred
alignment will tend to be in tighter agreement, corresponding to
sharper posterior probability defining the location of the homologous
region. 

Operationally, I would use the envelope coordinates to annotate domain
locations on target sequences, not the alignment coordinates. However,
be aware that when two weaker-scoring domains are close to each other,
envelope coordinates can and will overlap, corresponding to the
overlapping uncertainty of where one domain ends and another begins.
In contrast, alignment coordinates generally do not overlap (though
there are cases where even they will overlap\footnote{Not to mention
one (mercifully rare) bug/artifact that I'm betting alpha testers
don't even see an example of -- but we'll see.}).

The last column is the average posterior probability of the aligned
target sequence residues; effectively, the expected accuracy per
residue of the alignment.

For comparison, current Uniprot consensus annotation of Sevenless
shows seven domains:

\begin{sreoutput}
FT   DOMAIN      311    431       Fibronectin type-III 1.
FT   DOMAIN      436    528       Fibronectin type-III 2.
FT   DOMAIN      822    921       Fibronectin type-III 3.
FT   DOMAIN     1298   1392       Fibronectin type-III 4.
FT   DOMAIN     1680   1794       Fibronectin type-III 5.
FT   DOMAIN     1797   1897       Fibronectin type-III 6.
FT   DOMAIN     1898   1988       Fibronectin type-III 7.
\end{sreoutput}

Each of these overlaps with one of the domains identified by HMMER,
plus HMMER calls an additional two domains (numbered 4 and 9 in its
output).


Under the domain table, an ``optimal posterior accuracy'' alignment
\citep{Holmes98} is computed within each domain's envelope, and
displayed. For example, (skipping domain 1 because it's weak and
unconvincing), fibronectin III domain 2 of \prog{7LESS\_DROME} is
shown as:

\begin{sreoutput}
 == domain 2    score: 42.0 bits;  conditional E-value: 5.2e-15
                  ---CEEEEEEECTTEEEEEEE--S..SS--SEEEEEEEETTTCCGCEEEEEETTTSEEEEES--TT-EEEEEEEEEETTEE.E CS
          fn3   2 saptnlsvtevtstsltlsWsppe.gngpitgYeveyreknegeeekeltvpgtttsvtltgLkpgteYevrVqavngagegp 83 
                  sap++++++++++++l+++W+p++++ngpi+gY+++++++++++ ++e++vp++++s+++++L++gt+Y+++++++n++gegp
  7LESS_DROME 439 SAPVIEHLMGLDDSHLAVHWHPGRfTNGPIEGYRLRLSSSEGNA-TSEQLVPAGRGSYIFSQLQAGTNYTLALSMINKQGEGP 520
                  78888999999*****************************9997.**********************************9997 PP
\end{sreoutput}

The initial header line starts with a \prog{==} as a little handle for
a parsing script to grab hold of. The rest of that line, we'll
probably put more information on eventually.

If the model had any consensus structure or reference line annotation
that it inherited from your multiple alignment (\prog{\#=GC SS\_cons},
\prog{\#=GC RF} annotation in Stockholm files), that information is
simply regurgitated as \prog{CS} or \prog{RF} annotation lines
here. The \prog{fn3} model had a consensus structure annotation line.

The line starting with \prog{fn3} is the consensus of the query
model. Capital letters represent the most conserved (high information
content) positions. Dots (\prog{.}) in this line indicate insertions
in the target sequence with respect to the model.

The midline indicates matches between the query model and target
sequence. A \prog{+} indicates positive score, which can be
interpreted as ``conservative substitution'', with respect to what the
model expects at that position.

The line starting with \prog{7LESS\_DROME} is the target sequence.
Dashes (\prog{-}) in this line indicate deletions in the target
sequence with respect to the model.

The bottom line is new to HMMER3. This represents the posterior
probability (essentially the expected accuracy) of each aligned
residue. A 0 means 0-5\%, 1 means 5-15\%, and so on; 9 means 85-95\%,
and a \prog{*} means 95-100\% posterior probability. You can use these
posterior probabilities to decide which parts of the alignment are
well-determined or not. You'll often observe, for example, that
expected alignment accuracy degrades around locations of insertion and
deletion, which you'd intuitively expect. 

You'll also see expected alignment accuracy degrade at the ends of an
alignment -- this is because ``alignment accuracy'' posterior
probabilities currently not only includes whether the residue is
aligned to one model position versus others, but also confounded with
whether a residue should be considered to be homologous (aligned to
the model somewhere) versus not homologous at all.\footnote{It may
make more sense to condition the posterior probabilities on the
assumption that the residue is indeed homologous: given that, how
likely is it that I've got it correctly aligned.}


These domain table and per-domain alignment reports for each sequence
then continue, for each sequence that was in the per-sequence top hits
list.

Finally, at the bottom of the file, you'll see some summary
statistics.  For example, at the bottom of the globins search output,
you'll find something like:

\begin{sreoutput}
//
Internal statistics summary:
----------------------------
Query HMM(s):                              1  (148 nodes)
Target sequences:                     207132  (75438310 residues)
Passed MSV filter:                      7444  (0.0359384); expected 4142.6 (0.02)
Passed Vit filter:                      1602  (0.0077342); expected 207.1 (0.001)
Passed Fwd filter:                      1189  (0.0057403); expected 2.1 (1e-05)
Initial search space (seqZ):          207132  [actual number of target seqs]
Domain search space  (domZ):            1049  [number of seqs reported over threshold]
Mc/sec:                              1555.00
# CPU time: 7.18u 0.11s 00:00:07.29 Elapsed: 00:00:07
\end{sreoutput}

This gives you some idea of what's going on in HMMER3's acceleration
pipeline. You've got one query HMM, and the database has 207,132
target sequences. Each sequence goes through a gauntlet of three
scoring algorithms called MSV, Viterbi, and Forward, in order of 
increasing sensitivity and increasing computational requirement. 

MSV (the ``ungapped Multi Segment Viterbi'' algorithm) is the new
algorithm in HMMER3. It essentially calculates the HMM equivalent of
BLAST's sum score -- an optimal sum of ungapped high-scoring alignment
segments. Unlike BLAST, it does this calculation directly, without
BLAST's word hit or hit extension step, using a SIMD vector-parallel
algorithm. By default, HMMER3 is configured to allow sequences with a
P-value of $\leq 2$\% through the MSV score filter (thus, if the
database contained no homologs and P-values were accurately
calculated, the highest scoring 2\% of the sequences will pass the
filter). Here, about 3.6\% of the database got through the MSV filter.

The Viterbi filter then calculates a gapped optimal alignment score.
This is a bit more sensitive than the MSV score, but the Viterbi
filter is about three-fold slower than MSV. By default, HMMER3 lets
sequences with a P-value of $\leq 0.001$ through this stage. Here
(because there's a little over a thousand true globin homologs in this
database), much more than that gets through - 1602 sequences.

Then the full Forward score is calculated, which sums over all
possible alignments of the profile to the target sequence. The default
allows sequences with a P-value of $\leq 0.001$\% through; 1189
sequences passed.

All sequences that make it through the three filters are then
subjected to a full probabilistic analysis using the HMM
Forward/Backward algorithms, first to identify domains and assign
domain envelopes; then within each individual domain envelope,
Forward/Backward calculations are done to determine posterior
probabilities for each aligned residue, followed by optimal accuracy
alignment. The results of this step are what you finally see on the
output.

Recall the difference between conditional and independent E-values,
with their two different search space sizes; these search space sizes
are reported in the statistics summary. 

Finally, it reports the speed of the search in units of Mc/sec
(million dynamic programming cells per second), and the CPU time.
This search took 7.2 seconds. That's in the same ballpark as BLAST,
depending on which BLAST you compare to. On the same machine, an NCBI
BLAST with one of these globin sequences took 3.7 seconds, and
WU-BLAST took 8.5 seconds.



\subsection{Searching a profile HMM database with a query sequence}

The \prog{hmmscan} program is for annotating all the different
known/detectable domains in a given sequence. It takes a single query
sequence and an HMM database as input. The HMM database might be Pfam,
SMART, or TIGRFams, for example, or another collection of your choice.

\subsubsection{Step 1: create an HMM database flatfile}

An HMM ``database'' flatfile is simply a concatenation of individual
HMM files. To create a database flatfile, you can either build
individual HMM files and concatenate them, or you can concatenate
Stockholm alignments and use \prog{hmmbuild} to build an HMM database
of all of them in one command. 

Let's create a tiny database called \prog{minifam} containing models
of globin, fn3, and Pkinase (protein kinase) domains by concatenating
model files:

\user{hmmbuild globins4.hmm tutorial/globins4.sto}\\
\user{hmmbuild fn3.hmm tutorial/fn3.sto}\\
\user{hmmbuild Pkinase.hmm tutorial/Pkinase.sto}\\
\user{cat globins4.hmm fn3.hmm Pkinase.hmm > minifam}

We'll use \prog{minifam} for our examples in just a bit, but first a
few words on other ways to build HMM databases, especially big ones.
The file \prog{tutorials/minifam} is the same thing, if you want to
just use that.

Alternatively, you can concatenate Stockholm alignment files together
(as Pfam does in its big \prog{Pfam-A.seed} and \prog{Pfam-A.full}
flatfiles) and use \prog{hmmbuild} to build HMMs for all the
alignments at once. This won't work properly for our tutorial
alignments, because the \prog{globins4.sto} alignment doesn't have an
\prog{\#=GF ID} annotation line giving a name to the globins4
alignment, so \prog{hmmbuild} wouldn't know how to name it
correctly. To build a multi-model database from a multi-MSA flatfile,
the alignments have to be in Stockholm format (no other MSA format
that I'm aware of supports having more than one alignment per file),
and each alignment must have a name on a \prog{\#=GF ID} line.

But if you happen to have a Pfam seed alignment flatfile
\prog{Pfam-A.seed} around, an example command would be:

\user{hmmbuild Pfam-A.hmm Pfam-A.seed}

This would take about four hours to build all 10,000 models or so in
Pfam.  To speed the database construction process up, \prog{hmmbuild}
supports MPI parallelization,

As far as HMMER's concerned, all you have to do is add \prog{--mpi} to
the command line for \prog{hmmbuild}, assuming you've compiled support
for MPI into it; see the installation instructions.

You'll also need to know how to invoke an MPI job in your particular
environment, with your job scheduler and MPI distribution. We can't
really help you with this -- different sites have different cluster
environments.

With our scheduler (SGE, the Sun Grid Engine) and our MPI distro
(OpenMPI), an example incantation for building \prog{Pfam.hmm} from
\prog{Pfam-A.seed} is:

\user{qsub -N hmmbuild -j y -o errors.out -b y -cwd -V -pe openmpi 200\\
     'mpirun -mca btl self,tcp --prefix /usr/local/openmpi -np 200 ./hmmbuild --mpi Pfam.hmm Pfam-A.seed > hmmbuild.out'}

This reduces the time to build Pfam from about four hours to about a
minute.

\subsubsection{Step 2: compress and index the flatfile with hmmpress}

The \prog{hmmscan} program has to read a lot of profile HMMs in a
hurry, and HMMER's ASCII flatfiles are bulky. To accelerate this,
\prog{hmmscan} uses binary compression and indexing of the flatfiles.
To use \prog{hmmscan}, you must first compress and index your HMM
database with the \prog{hmmpress} program:

\user{hmmpress minifam}

This will quickly produce:

\begin{sreoutput}
Working...    done.
Pressed and indexed 3 HMMs (3 names and 2 accessions).
Models pressed into binary file:   minifam.h3m
SSI index for binary model file:   minifam.h3i
Profiles (MSV part) pressed into:  minifam.h3f
Profiles (remainder) pressed into: minifam.h3p
\end{sreoutput}

and you'll see these four new binary files in the directory. 

The \prog{tutorial/minifam} example has already been pressed, so there
are example binary files \prog{tutorial/minifam.h3\{m,i,f,p\}}
included in the tutorial.

Their format is ``proprietary'', which is an open source term of art
meaning ``haven't found time to document them yet''.



\subsubsection{Step 3: search the HMM database with hmmscan}

Now we can analyze sequences using our HMM database and
\prog{hmmscan}. 

For example, the receptor tyrosine kinase \prog{7LESS\_DROME} not only
has all those fibronectin type III domains on its extracellular face,
it's got a protein kinase domain on its intracellular face. Our
\prog{minifam} database has models of both \prog{fn3} and
\prog{Pkinase}, as well as the unrelated \prog{globins4} model. So
what happens when we scan the \prog{7LESS\_DROME} sequence:

\user{hmmscan minifam tutorial/7LESS\_DROME} 

The header and the first section of the output will look like:

\begin{sreoutput}
# hmmscan :: search sequence(s) against a profile HMM database
# HMMER 3.0a1 (January 2009); http://hmmer.org/
# Copyright (C) 2009 Howard Hughes Medical Institute.
# Freely distributed under the GNU General Public License (GPLv3).
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# query sequence file:             tutorial/7LESS_DROME
# target HMM database:             tutorial/minifam
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Query:       7LESS_DROME  [L=2554]
Accession:   P13368
Description: RecName: Full=Protein sevenless;          EC=2.7.10.1;
Scores for complete sequence (score includes all domains):
 --- full sequence ---   --- best 1 domain ---    -#dom-
  E-value  score  bias    E-value  score  bias    exp  N  Model    Description
  ------- ------ -----    ------- ------ -----   ---- --  -------- -----------
  7.4e-56  174.0   0.0    6.2e-15   43.3   0.4    9.6  9  fn3      Fibronectin type III domain
  5.9e-43  135.0   0.0    9.2e-43  134.4   0.0    1.3  1  Pkinase  Protein kinase domain
     0.75   -2.5   0.0          0    0.0   0.0    1.2  0  globins4
\end{sreoutput}

The output fields are in the same order and have the same meaning as
in \prog{hmmsearch}'s output. 

The size of the search space for \prog{hmmscan} is the number of
models in the HMM database (here, 3; for a Pfam search, on the order
of 10000). In \prog{hmmsearch}, the size of the search space is the
number of sequences in the sequence database. This means that E-values
may differ even for the same individual profile vs. sequence
comparison, depending on how you do the search.

For domain, there then follows a domain table and alignment output,
just as in \prog{hmmsearch}. The \prog{fn3} annotation, for example,
looks like:

\begin{sreoutput}
>> fn3  Fibronectin type III domain
     # bit score    bias    E-value ind Evalue hmm from   hmm to    ali from   ali to    env from   env to    ali-acc
   --- --------- ------- ---------- ---------- -------- --------    -------- --------    -------- --------    -------
     1      -2.3     0.0        1.1        1.1       60       72 ..      396      408 ..      395      410 ..    0.86
     2      42.0     0.0    1.5e-14    1.5e-14        2       83 ..      439      520 ..      437      521 ..    0.95
     3      15.1     0.0      4e-06      4e-06       14       82 ..      837      911 ..      827      914 ..    0.82
     4       3.6     0.0      0.017      0.017        6       35 ..     1205     1235 ..     1202     1258 ..    0.81
     5      22.9     0.0    1.5e-08    1.5e-08       13       79 ..     1312     1380 ..     1304     1385 ..    0.81
     6      -0.6     0.0       0.34       0.34       57       72 ..     1754     1769 ..     1747     1769 ..    0.87
     7      43.3     0.4    6.2e-15    6.2e-15        1       82 [.     1799     1888 ..     1799     1891 ..    0.89
     8      19.2     0.0    2.2e-07    2.2e-07        6       73 ..     1904     1966 ..     1900     1976 ..    0.90
     9      12.0     0.0    3.7e-05    3.7e-05        1       77 [.     1993     2098 ..     1993     2107 ..    0.74
\end{sreoutput}

and an example alignment (of that second domain again):

\begin{sreoutput}
  == domain 2    score: 42.0 bits;  conditional E-value: 1.5e-14
                  ---CEEEEEEECTTEEEEEEE--S..SS--SEEEEEEEETTTCCGCEEEEEETTTSEEEEES--TT-EEEEEEEEEETTEE.E CS
          fn3   2 saptnlsvtevtstsltlsWsppe.gngpitgYeveyreknegeeekeltvpgtttsvtltgLkpgteYevrVqavngagegp 83
                  sap++++++++++++l+++W+p++++ngpi+gY+++++++++++ ++e++vp++++s+++++L++gt+Y+++++++n++gegp
  7LESS_DROME 439 SAPVIEHLMGLDDSHLAVHWHPGRfTNGPIEGYRLRLSSSEGNA-TSEQLVPAGRGSYIFSQLQAGTNYTLALSMINKQGEGP 520
                  78888999999*****************************9997.**********************************9997 PP
\end{sreoutput}

You'd think (and you'd usually be right) that except for the E-values
(which depend on database search space sizes), you should get exactly
the same scores, domain number, domain coordinates, and alignment
every time you do a search of the same HMM against the same
sequence. And in this case, with the comparison of the \prog{fn3}
model and \prog{7LESS\_DROME}, that's what's happened. But it isn't
guaranteed to happen. In some cases, particularly cases where exact
domain number and boundaries are difficult to infer, HMMER3 uses
stochastic sampling algorithms. Therefore you may see differences from
run to run. We know this isn't what many people expect or like -- even
though probabilistically it's just another way that HMMER's more or
less correctly reflecting true uncertainty of its inferences. We plan
to implement some ways to make results more reproducible by default,
by more precisely controlling the state of the pseudorandom number
generators.



\subsection{Creating multiple alignments with hmmalign}

The file \prog{tutorial/globins45.fa} is a FASTA file containing 45
unaligned globin sequences. To align all of these to the
\prog{globins4} model and make a multiple sequence alignment:

\user{hmmalign globins4.hmm tutorial/globins45.fa}

The output of this is a Stockholm format multiple alignment file. The
first few lines of it look like:

\begin{sreoutput}
# STOCKHOLM 1.0

MYG_ESCGI          ...VLSDAEWQLVLNIWAKVEADVAGHGQDILIRLFKGHPETLEKFDKFK
#=GR MYG_ESCGI  PP ...69*********************************************
MYG_HORSE          ..g-LSDGEWQQVLNVWGKVEADIAGHGQEVLIRLFTGHPETLEKFDKFK
#=GR MYG_HORSE  PP ..7.89********************************************
MYG_PROGU          ..g-LSDGEWQLVLNVWGKVEGDLSGHGQEVLIRLFKGHPETLEKFDKFK
#=GR MYG_PROGU  PP ..7.89********************************************
MYG_SAISC          ..g-LSDGEWQLVLNIWGKVEADIPSHGQEVLISLFKGHPETLEKFDKFK
#=GR MYG_SAISC  PP ..7.89********************************************
MYG_LYCPI          ..g-LSDGEWQIVLNIWGKVETDLAGHGQEVLIRLFKNHPETLDKFDKFK
#=GR MYG_LYCPI  PP ..7.89********************************************
MYG_MOUSE          ..g-LSDGEWQLVLNVWGKVEADLAGHGQEVLIGLFKTHPETLDKFDKFK
#=GR MYG_MOUSE  PP ..7.89********************************************
MYG_MUSAN          ..v-----DWEKVNSVWSAVESDLTAIGQNILLRLFEQYPESQNHFPKFK
#=GR MYG_MUSAN  PP ..7.....89***************************************9
...
\end{sreoutput}

and so on. 

Notice those \prog{PP} annotation lines. That's posterior probability
annotation, as in the single sequence alignments that \prog{hmmscan}
and \prog{hmmsearch} showed. This essentially represents the
confidence that each residue is aligned where it should be.

\prog{hmmalign} currently has an undesirable/problematic ``feature''
that we're aware of. Recall that HMMER3 only does local
alignments. Here, we know that we've provided full length globin
sequences, and \prog{globins4} is a full length globin model. We'd
really like \prog{hmmalign} to produce a global alignment. It can't
currently do that. If it doesn't quite manage to extend its local
alignment to the full length of a target globin sequence, you'll get a
weird-looking effect, as the nonmatching termini are pulled out to the
left or right. For example, look at the N-terminal \prog{g} in
\prog{MYG\_HORSE} above. H3 is about 70\% confident that this residue
is nonhomologous, though any sensible person would align it into the
first globin consensus column.

Look at the end of that first block of Stockholm alignment, where you'll
see:

\begin{sreoutput}
...
HBBL_RANCA         vhw--TAEEKAVINSVWQKV--DVEQDGHEALTRLFIVYPWTQRYFSTFG
#=GR HBBL_RANCA PP *65..899************..****************************
HBB2_TRICR         ..vHLTAEDRKEIAAILGKV--NVDSLGGQCLARLIVVNPWSRRYFHDFG
#=GR HBB2_TRICR PP ..*79***************..****************************
#=GC PP_cons       ...799********************************************
\end{sreoutput}

The \prog{\#=GC PP\_cons} line is Stockholm-format \emph{consensus
posterior probability} annotation for the entire column. It's
calculated simply as the arithmetic mean of the per-residue posterior
probabilities in that column. This should prove useful in phylogenetic
inference applications, for example, where it's common to mask away
nonconfidently aligned columns of a multiple alignment. The
\prog{PP\_cons} line provides an objective measure of the confidence
assigned to each column.



\subsection{Single sequence queries using phmmer}

The \prog{phmmer} program is for searching a single sequence query
against a sequence database, much as \prog{BLASTP} or \prog{FASTA}
would do. \prog{phmmer} works essentially just like \prog{hmmsearch}
does, except you provide a query sequence instead of a query profile
HMM. 

Internally, HMMER builds a profile HMM from your single query
sequence, using a simple position-independent scoring system (BLOSUM62
scores converted to probabilities, plus a gap-open and gap-extend
probability).

The file \prog{tutorial/HBB\_HUMAN} is a FASTA file containing the
human $\beta-$globin sequence as an example query. If you have a
sequence database such as \prog{uniprot\_sprot.fasta}, make that your
target database; otherwise, use \prog{tutorial/globins45.fa} as a
small example:

\user{phmmer tutorial/HBB\_HUMAN uniprot\_sprot.fa}\\
or\\
\user{phmmer tutorial/HBB\_HUMAN tutorial/globins45.fa}

Everything about the output is essentially as previously described for
\prog{hmmsearch}. 
















